; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28107.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
szTwoSpaces DB	020H
	DB	00H
	ORG $+2
szOneSpace DB	020H
	DB	00H
CONST	ENDS
PUBLIC	UniDump
PUBLIC	GetMem8
PUBLIC	WriteString
PUBLIC	vsnprintfwrapper
PUBLIC	vsprintfwrapper
PUBLIC	vprintfwrapper
PUBLIC	vsscanfwrapper
PUBLIC	main
EXTRN	tmpnam:PROC
EXTRN	vprintf:PROC
EXTRN	printf:PROC
EXTRN	vsnprintf:PROC
EXTRN	vsprintf:PROC
EXTRN	sprintf:PROC
EXTRN	snprintf:PROC
EXTRN	vsscanf:PROC
EXTRN	sscanf:PROC
EXTRN	memset:PROC
EXTRN	strlen:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	isalnum:PROC
EXTRN	_CdeMofine:PROC
EXTRN	gEfiCallerBaseName:QWORD
_BSS	SEGMENT
$SG11117 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UniDump DD imagerel $LN40
	DD	imagerel $LN40+1049
	DD	imagerel $unwind$UniDump
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WriteString DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$WriteString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PrintAscii DD imagerel PrintAscii
	DD	imagerel PrintAscii+594
	DD	imagerel $unwind$PrintAscii
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsnprintfwrapper DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$vsnprintfwrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsprintfwrapper DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$vsprintfwrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vprintfwrapper DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$vprintfwrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsscanfwrapper DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$vsscanfwrapper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN33
	DD	imagerel $LN33+5586
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG10979 DB	'%s', 00H
	ORG $+1
$SG11044 DB	'%c', 00H
	ORG $+1
$SG11048 DB	'%c', 00H
	ORG $+1
$SG11050 DB	' ', 00H
	ORG $+2
$SG11052 DB	'%c', 00H
	ORG $+1
$SG11054 DB	' ', 00H
	ORG $+2
$SG11056 DB	'%c', 00H
	ORG $+1
$SG11058 DB	' ', 00H
	ORG $+2
$SG11109 DB	'%016llX: ', 00H
	ORG $+2
$SG11120 DB	'- ', 00H
	ORG $+1
$SG11111 DB	'%08llX: ', 00H
	ORG $+3
$SG11123 DB	'%02X ', 00H
	ORG $+2
$SG11132 DB	0aH, 00H
	ORG $+2
$SG11113 DB	'%04llX: ', 00H
	ORG $+3
$SG11125 DB	'%04X ', 00H
	ORG $+2
$SG11135 DB	0aH, 00H
	ORG $+2
$SG11115 DB	'%02llX: ', 00H
	ORG $+3
$SG11127 DB	'%08X ', 00H
	ORG $+2
$SG11138 DB	0aH, 00H
	ORG $+2
$SG11129 DB	'%016llX ', 00H
	ORG $+3
$SG11234 DB	'INFO>', 00H
	ORG $+6
$SG11233 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11235 DB	'main', 00H
	ORG $+7
$SG11236 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11237 DB	'x86-64', 00H
	ORG $+1
$SG11518 DB	'%s', 0aH, 00H
$SG11238 DB	'NT(Torito C Library)', 00H
	ORG $+3
$SG11240 DB	'INFO>', 00H
	ORG $+2
$SG11239 DB	'########################## CdePkg driver stdiohfunctions'
	DB	' %s %s', 0aH, 00H
$SG11241 DB	'main', 00H
	ORG $+3
$SG11244 DB	'INFO>', 00H
	ORG $+2
$SG11242 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11245 DB	'main', 00H
	ORG $+7
$SG11243 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11248 DB	'INFO>', 00H
	ORG $+6
$SG11246 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11249 DB	'main', 00H
	ORG $+7
$SG11247 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int remove(const char* filename)', 0aH, 00H
	ORG $+6
$SG11250 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11252 DB	'INFO>', 00H
	ORG $+6
$SG11251 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int rename(const char* old, const char* new)', 0aH, 00H
	ORG $+2
$SG11253 DB	'main', 00H
	ORG $+3
$SG11254 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11256 DB	'INFO>', 00H
	ORG $+6
$SG11255 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'FILE* tmpfile(void)', 0aH, 00H
	ORG $+3
$SG11257 DB	'main', 00H
	ORG $+3
$SG11260 DB	'INFO>', 00H
	ORG $+2
$SG11258 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11261 DB	'main', 00H
	ORG $+7
$SG11259 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'char* tmpnam(char* s)', 0aH, 00H
	ORG $+1
$SG11262 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11264 DB	'INFO>', 00H
	ORG $+6
$SG11263 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fclose(FILE * stream)', 0aH, 00H
	ORG $+1
$SG11265 DB	'main', 00H
	ORG $+7
$SG11266 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11268 DB	'INFO>', 00H
	ORG $+6
$SG11267 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fflush(FILE * stream)', 0aH, 00H
	ORG $+1
$SG11269 DB	'main', 00H
	ORG $+7
$SG11270 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11272 DB	'INFO>', 00H
	ORG $+6
$SG11271 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'FILE* fopen(const char* filename, const char* mode)', 0aH, 00H
	ORG $+3
$SG11273 DB	'main', 00H
	ORG $+3
$SG11276 DB	'INFO>', 00H
	ORG $+2
$SG11274 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11277 DB	'main', 00H
	ORG $+7
$SG11275 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'FILE* freopen(const char* filename, const char* mode, FILE * '
	DB	'stream)', 0aH, 00H
	ORG $+2
$SG11278 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11280 DB	'INFO>', 00H
	ORG $+6
$SG11279 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'void setbuf(FILE * stream, char* buf)', 0aH, 00H
	ORG $+1
$SG11281 DB	'main', 00H
	ORG $+3
$SG11284 DB	'INFO>', 00H
	ORG $+2
$SG11282 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11285 DB	'main', 00H
	ORG $+7
$SG11283 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int setvbuf(FILE * stream, char* buf, int mode, size_t size)', 0aH
	DB	00H
	ORG $+2
$SG11288 DB	'INFO>', 00H
	ORG $+2
$SG11286 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11289 DB	'main', 00H
	ORG $+7
$SG11287 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fprintf(FILE * stream, const char* format, ...)', 0aH, 00H
	ORG $+3
$SG11290 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11292 DB	'INFO>', 00H
	ORG $+6
$SG11291 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fscanf(FILE * stream, const char* format, ...)', 0aH, 00H
$SG11293 DB	'main', 00H
	ORG $+3
$SG11296 DB	'INFO>', 00H
	ORG $+6
$SG11294 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11297 DB	'main', 00H
	ORG $+7
$SG11295 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int printf(const char* format, ...)', 0aH, 00H
	ORG $+3
$SG11298 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11300 DB	'INFO>', 00H
	ORG $+6
$SG11299 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int scanf(const char* format, ...)', 0aH, 00H
$SG11301 DB	'main', 00H
	ORG $+3
$SG11304 DB	'INFO>', 00H
	ORG $+6
$SG11302 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11305 DB	'main', 00H
	ORG $+7
$SG11303 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int snprintf(char* s, size_t n, const char* format, ...)', 0aH
	DB	00H
	ORG $+2
$SG11308 DB	'INFO>', 00H
	ORG $+6
$SG11306 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11309 DB	'main', 00H
	ORG $+7
$SG11307 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int sprintf(char* s, const char* format, ...)', 0aH, 00H
	ORG $+1
$SG11312 DB	'INFO>', 00H
	ORG $+2
$SG11310 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11313 DB	'main', 00H
	ORG $+7
$SG11311 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int vscanf(const char* format, va_list arg) from C99', 0aH, 00H
	ORG $+2
$SG11314 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11316 DB	'INFO>', 00H
	ORG $+6
$SG11315 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int vsnprintf(char* s, size_t n, const char* format, va_list '
	DB	'arg) from C99', 0aH, 00H
$SG11317 DB	'main', 00H
	ORG $+7
$SG11318 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11320 DB	'INFO>', 00H
	ORG $+6
$SG11319 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int vsscanf(const char* s, const char* format, va_list arg) f'
	DB	'rom C99', 0aH, 00H
	ORG $+2
$SG11321 DB	'main', 00H
	ORG $+3
$SG11324 DB	'INFO>', 00H
	ORG $+2
$SG11322 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11325 DB	'main', 00H
	ORG $+7
$SG11323 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int sscanf(const char* s, const char* format, ...)', 0aH, 00H
	ORG $+4
$SG11326 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11328 DB	'INFO>', 00H
	ORG $+6
$SG11327 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int vfprintf(FILE * stream, const char* format, va_list arg)', 0aH
	DB	00H
	ORG $+2
$SG11329 DB	'main', 00H
	ORG $+3
$SG11330 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11332 DB	'INFO>', 00H
	ORG $+6
$SG11331 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int vprintf(const char* format, va_list arg)', 0aH, 00H
	ORG $+2
$SG11333 DB	'main', 00H
	ORG $+3
$SG11334 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11336 DB	'INFO>', 00H
	ORG $+6
$SG11335 DB	'Function will     be available for PEI/DXE POST driver: '
	DB	'int vsprintf(char* s, const char* format, va_list arg)', 0aH, 00H
$SG11337 DB	'main', 00H
	ORG $+3
$SG11340 DB	'INFO>', 00H
	ORG $+2
$SG11338 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11341 DB	'main', 00H
	ORG $+7
$SG11339 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fgetc(FILE * stream)', 0aH, 00H
	ORG $+2
$SG11344 DB	'INFO>', 00H
	ORG $+6
$SG11342 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11345 DB	'main', 00H
	ORG $+7
$SG11343 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'char* fgets(char* s, int n, FILE * stream)', 0aH, 00H
$SG11348 DB	'INFO>', 00H
	ORG $+6
$SG11346 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11349 DB	'main', 00H
	ORG $+7
$SG11347 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fputc(int c, FILE * stream)', 0aH, 00H
	ORG $+7
$SG11350 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11352 DB	'INFO>', 00H
	ORG $+6
$SG11351 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fputs(const char* s, FILE * stream)', 0aH, 00H
	ORG $+3
$SG11353 DB	'main', 00H
	ORG $+7
$SG11354 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11356 DB	'INFO>', 00H
	ORG $+6
$SG11355 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int getc(FILE * stream)', 0aH, 00H
	ORG $+3
$SG11357 DB	'main', 00H
	ORG $+7
$SG11358 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11360 DB	'INFO>', 00H
	ORG $+6
$SG11359 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int getchar(void)', 0aH, 00H
	ORG $+1
$SG11361 DB	'main', 00H
	ORG $+3
$SG11364 DB	'INFO>', 00H
	ORG $+6
$SG11362 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11365 DB	'main', 00H
	ORG $+7
$SG11363 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'char* gets(char* s)', 0aH, 00H
	ORG $+3
$SG11366 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11368 DB	'INFO>', 00H
	ORG $+6
$SG11367 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int putc(int c, FILE * stream)', 0aH, 00H
$SG11369 DB	'main', 00H
	ORG $+3
$SG11370 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11372 DB	'INFO>', 00H
	ORG $+6
$SG11371 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int putchar(int c)', 0aH, 00H
$SG11373 DB	'main', 00H
	ORG $+3
$SG11376 DB	'INFO>', 00H
	ORG $+6
$SG11374 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11377 DB	'main', 00H
	ORG $+7
$SG11375 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int puts(const char* s)', 0aH, 00H
	ORG $+3
$SG11380 DB	'INFO>', 00H
	ORG $+6
$SG11378 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11381 DB	'main', 00H
	ORG $+7
$SG11379 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int ungetc(int c, FILE * stream)', 0aH, 00H
	ORG $+6
$SG11382 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11384 DB	'INFO>', 00H
	ORG $+6
$SG11383 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'size_t fread(void* ptr, size_t size, size_t nmemb, FILE * str'
	DB	'eam)', 0aH, 00H
	ORG $+1
$SG11385 DB	'main', 00H
	ORG $+3
$SG11388 DB	'INFO>', 00H
	ORG $+6
$SG11386 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11389 DB	'main', 00H
	ORG $+7
$SG11387 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'size_t fwrite(const void* ptr, size_t size, size_t nmemb, FIL'
	DB	'E * stream)', 0aH, 00H
	ORG $+2
$SG11392 DB	'INFO>', 00H
	ORG $+6
$SG11390 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11393 DB	'main', 00H
	ORG $+7
$SG11391 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fgetpos(FILE * stream, fpos_t * pos)', 0aH, 00H
	ORG $+2
$SG11396 DB	'INFO>', 00H
	ORG $+6
$SG11394 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11397 DB	'main', 00H
	ORG $+7
$SG11395 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fseek(FILE * stream, long int offset, int whence)', 0aH, 00H
	ORG $+1
$SG11398 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11400 DB	'INFO>', 00H
	ORG $+6
$SG11399 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int fsetpos(FILE * stream, const fpos_t * pos)', 0aH, 00H
$SG11401 DB	'main', 00H
	ORG $+3
$SG11402 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11404 DB	'INFO>', 00H
	ORG $+6
$SG11403 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'long int ftell(FILE * stream)', 0aH, 00H
	ORG $+1
$SG11405 DB	'main', 00H
	ORG $+3
$SG11406 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11408 DB	'INFO>', 00H
	ORG $+6
$SG11407 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'void rewind(FILE * stream)', 0aH, 00H
$SG11409 DB	'main', 00H
	ORG $+7
$SG11410 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11412 DB	'INFO>', 00H
	ORG $+6
$SG11411 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'void clearerr(FILE * stream)', 0aH, 00H
	ORG $+2
$SG11413 DB	'main', 00H
	ORG $+3
$SG11414 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11416 DB	'INFO>', 00H
	ORG $+6
$SG11415 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int feof(FILE * stream)', 0aH, 00H
	ORG $+3
$SG11417 DB	'main', 00H
	ORG $+7
$SG11418 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11420 DB	'INFO>', 00H
	ORG $+6
$SG11419 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'int ferror(FILE * stream)', 0aH, 00H
	ORG $+1
$SG11421 DB	'main', 00H
	ORG $+7
$SG11422 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11424 DB	'INFO>', 00H
	ORG $+6
$SG11423 DB	'Function will not be available for PEI/DXE POST driver: '
	DB	'void perror(const char* s)', 0aH, 00H
$SG11425 DB	'main', 00H
	ORG $+7
$SG11426 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11428 DB	'INFO>', 00H
	ORG $+6
$SG11427 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11429 DB	'main', 00H
	ORG $+7
$SG11430 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11431 DB	'### Demonstrating "char* tmpnam(char* s)"', 0aH, 00H
	ORG $+1
$SG11432 DB	'INFO>', 00H
	ORG $+2
$SG11433 DB	'main', 00H
	ORG $+3
$SG11436 DB	'INFO>', 00H
	ORG $+6
$SG11434 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11437 DB	'main', 00H
	ORG $+7
$SG11435 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11441 DB	'INFO>', 00H
	ORG $+6
$SG11438 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11440 DB	'TMPNAM # %2d: %s', 0aH, 00H
	ORG $+2
$SG11442 DB	'main', 00H
	ORG $+3
$SG11445 DB	'INFO>', 00H
	ORG $+6
$SG11443 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11446 DB	'main', 00H
	ORG $+7
$SG11444 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11449 DB	'INFO>', 00H
	ORG $+6
$SG11447 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11448 DB	'### Demonstrating "int printf(const char * format, ...)"'
	DB	0aH, 00H
	ORG $+2
$SG11450 DB	'main', 00H
	ORG $+7
$SG11451 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11453 DB	'INFO>', 00H
	ORG $+6
$SG11452 DB	'### Demonstrating "int sprintf(char * s ,const char * fo'
	DB	'rmat, ...)"', 0aH, 00H
	ORG $+3
$SG11454 DB	'main', 00H
	ORG $+3
$SG11455 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11457 DB	'INFO>', 00H
	ORG $+6
$SG11456 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11458 DB	'main', 00H
	ORG $+7
$SG11459 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11465 DB	'INFO>', 00H
	ORG $+6
$SG11461 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11462 DB	'%s(%d): printf() -> Welcome, to the jungle... ', 0aH, 00H
$SG11463 DB	'sprintf() -> Welcome, to the jungle... ', 0aH, 00H
	ORG $+7
$SG11464 DB	'Chars written: %d, %s', 0aH, 00H
	ORG $+1
$SG11466 DB	'main', 00H
	ORG $+3
$SG11469 DB	'INFO>', 00H
	ORG $+2
$SG11467 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11470 DB	'main', 00H
	ORG $+7
$SG11468 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11473 DB	'INFO>', 00H
	ORG $+6
$SG11471 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11474 DB	'main', 00H
	ORG $+7
$SG11472 DB	'### Demonstrating "int snprintf(char* s, size_t n, const'
	DB	' char* format, ...)"', 0aH, 00H
	ORG $+2
$SG11475 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11477 DB	'INFO>', 00H
	ORG $+6
$SG11476 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11478 DB	'main', 00H
	ORG $+7
$SG11479 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11481 DB	'snprintf()', 00H
	ORG $+5
$SG11482 DB	'cnt = %2d, n = %2d: %s.', 0aH, 00H
	ORG $+3
$SG11483 DB	'INFO>', 00H
	ORG $+2
$SG11484 DB	'main', 00H
	ORG $+3
$SG11487 DB	'INFO>', 00H
	ORG $+6
$SG11485 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11488 DB	'main', 00H
	ORG $+7
$SG11486 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11491 DB	'INFO>', 00H
	ORG $+6
$SG11489 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11492 DB	'main', 00H
	ORG $+7
$SG11490 DB	'### Demonstrating "int vsnprintf(char* s, size_t n, cons'
	DB	't char* format, va_list ap)"', 0aH, 00H
	ORG $+2
$SG11495 DB	'INFO>', 00H
	ORG $+2
$SG11493 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11496 DB	'main', 00H
	ORG $+7
$SG11494 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11501 DB	'INFO>', 00H
	ORG $+6
$SG11497 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11499 DB	'vsnprintf()', 0aH, 00H
	ORG $+3
$SG11500 DB	'cnt = %2d, n = %2d: %s.', 0aH, 00H
	ORG $+3
$SG11502 DB	'main', 00H
	ORG $+7
$SG11503 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11505 DB	'INFO>', 00H
	ORG $+6
$SG11504 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11506 DB	'main', 00H
	ORG $+7
$SG11507 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11509 DB	'INFO>', 00H
	ORG $+6
$SG11508 DB	'### Demonstrating "int vsprintf(char* s, const char* for'
	DB	'mat, va_list arg)"', 0aH, 00H
$SG11510 DB	'main', 00H
	ORG $+3
$SG11513 DB	'INFO>', 00H
	ORG $+6
$SG11511 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11514 DB	'main', 00H
	ORG $+7
$SG11512 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11519 DB	'INFO>', 00H
	ORG $+6
$SG11515 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11517 DB	'vsprintf() -> Welcome, to the jungle... ', 0aH, 00H
	ORG $+2
$SG11520 DB	'main', 00H
	ORG $+7
$SG11521 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11523 DB	'INFO>', 00H
	ORG $+6
$SG11522 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11524 DB	'main', 00H
	ORG $+7
$SG11525 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11527 DB	'INFO>', 00H
	ORG $+6
$SG11526 DB	'### Demonstrating "int vprintf(const char* format, va_li'
	DB	'st arg)"', 0aH, 00H
	ORG $+2
$SG11528 DB	'main', 00H
	ORG $+7
$SG11529 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11531 DB	'INFO>', 00H
	ORG $+6
$SG11530 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11532 DB	'main', 00H
	ORG $+7
$SG11533 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11535 DB	'vprintf() -> Welcome, to the jungle... ', 0aH, 00H
	ORG $+3
$SG11537 DB	'INFO>', 00H
	ORG $+6
$SG11536 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11538 DB	'main', 00H
	ORG $+7
$SG11539 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11541 DB	'INFO>', 00H
	ORG $+6
$SG11540 DB	'### Demonstrating "sscanf(const char* s, const char* for'
	DB	'mat, ...)"', 0aH, 00H
$SG11542 DB	'main', 00H
	ORG $+7
$SG11543 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11545 DB	'INFO>', 00H
	ORG $+6
$SG11544 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11546 DB	'main', 00H
	ORG $+7
$SG11547 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11549 DB	'1 22 333 STR1   STR2', 00H
	ORG $+3
$SG11550 DB	'%d %d %d %s %s', 00H
	ORG $+1
$SG11551 DB	'token = %d, no1 %d, no2 %d, no3 %d, str1 %s, str2 %s', 0aH
	DB	00H
	ORG $+2
$SG11552 DB	'INFO>', 00H
	ORG $+2
$SG11553 DB	'main', 00H
	ORG $+3
$SG11556 DB	'INFO>', 00H
	ORG $+2
$SG11554 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11557 DB	'main', 00H
	ORG $+7
$SG11555 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11560 DB	'INFO>', 00H
	ORG $+6
$SG11558 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11561 DB	'main', 00H
	ORG $+7
$SG11559 DB	'### Demonstrating "vsscanf(const char* s, const char* fo'
	DB	'rmat, va_list arg)"', 0aH, 00H
	ORG $+3
$SG11562 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
$SG11564 DB	'INFO>', 00H
	ORG $+6
$SG11563 DB	'########################################################'
	DB	'##########', 0aH, 00H
$SG11565 DB	'main', 00H
	ORG $+7
$SG11566 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
	ORG $+4
$SG11568 DB	'111 22 3 STRing   STRINg', 00H
	ORG $+7
$SG11569 DB	'%d %d %d %s %s', 00H
	ORG $+1
$SG11570 DB	'token = %d, no1 %d, no2 %d, no3 %d, str1 %s, str2 %s', 0aH
	DB	00H
	ORG $+2
$SG11571 DB	'INFO>', 00H
	ORG $+2
$SG11572 DB	'main', 00H
	ORG $+3
$SG11573 DB	'B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunct'
	DB	'ions\main.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	091801H
	DD	0243418H
	DD	01e0118H
	DD	0d00af00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsscanfwrapper DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vprintfwrapper DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsprintfwrapper DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsnprintfwrapper DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PrintAscii DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0b341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WriteString DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UniDump DD 091e01H
	DD	0f01ac21eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
	DD	0300fH
xdata	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT main
_TEXT	SEGMENT
str1$1 = 112
str2$2 = 112
str2$3 = 120
str1$4 = 120
no1$5 = 128
no1$6 = 128
buffer$7 = 136
buffer$8 = 136
b$ = 176
argc$ = 288
argv$ = 296
no3$9 = 304
no3$10 = 304
no2$11 = 312
no2$12 = 312
main	PROC						; COMDAT

; 343  : int main(int argc, char** argv) {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 55		 push	 r13
  0000a	41 57		 push	 r15
  0000c	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  00011	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 344  : 
; 345  :     char b[64];
; 346  :     UNIDUMPPARM hexparms = { .reg = 0, .bit.elmsizemin1 = 1 - 1, .bit.fBaseOfs = 0 };
; 347  : 
; 348  :     //__debugbreak(); NOTE: to use breakpoints run DBGEMU.BAT
; 349  : 
; 350  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11233
  00026	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0002b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11235
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11234
  00039	33 db		 xor	 ebx, ebx
  0003b	41 b8 5e 01 00
	00		 mov	 r8d, 350		; 0000015eH
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11236
  00048	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  0004b	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0004f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00054	e8 00 00 00 00	 call	 _CdeMofine

; 351  :     CDEMOFINE((MFNINF(1) "########################## CdePkg driver stdiohfunctions %s %s\n", CDE_CONFIGURATION_STRING, CDE_PLATFORM_STRING));

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11237
  00067	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11241
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11238
  0007a	41 b8 5f 01 00
	00		 mov	 r8d, 351		; 0000015fH
  00080	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11242
  0008c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11239
  00093	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11240
  0009f	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  000a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a8	e8 00 00 00 00	 call	 _CdeMofine

; 352  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  000ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11243
  000bb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000c0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11245
  000c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11244
  000ce	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  000d2	41 b8 60 01 00
	00		 mov	 r8d, 352		; 00000160H
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11246
  000e4	e8 00 00 00 00	 call	 _CdeMofine

; 353  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int remove(const char* filename)\n"));

  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11247
  000f7	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11249
  00103	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11248
  0010a	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0010e	41 b8 61 01 00
	00		 mov	 r8d, 353		; 00000161H
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11250
  00120	e8 00 00 00 00	 call	 _CdeMofine

; 354  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int rename(const char* old, const char* new)\n"));

  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11251
  00133	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00138	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11253
  0013f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11252
  00146	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0014a	41 b8 62 01 00
	00		 mov	 r8d, 354		; 00000162H
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11254
  0015c	e8 00 00 00 00	 call	 _CdeMofine

; 355  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: FILE* tmpfile(void)\n"));

  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00168	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11255
  0016f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00174	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11257
  0017b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11256
  00182	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00186	41 b8 63 01 00
	00		 mov	 r8d, 355		; 00000163H
  0018c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11258
  00198	e8 00 00 00 00	 call	 _CdeMofine

; 356  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: char* tmpnam(char* s)\n"));

  0019d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  001a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11259
  001ab	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001b0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11261
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11260
  001be	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  001c2	41 b8 64 01 00
	00		 mov	 r8d, 356		; 00000164H
  001c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11262
  001d4	e8 00 00 00 00	 call	 _CdeMofine

; 357  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fclose(FILE * stream)\n"));

  001d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11263
  001e0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11264
  001ec	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  001f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  001fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11265
  00203	41 b8 65 01 00
	00		 mov	 r8d, 357		; 00000165H
  00209	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11266
  00210	e8 00 00 00 00	 call	 _CdeMofine

; 358  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fflush(FILE * stream)\n"));

  00215	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  0021c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11267
  00223	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00228	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11269
  0022f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11268
  00236	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0023a	41 b8 66 01 00
	00		 mov	 r8d, 358		; 00000166H
  00240	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00245	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11270
  0024c	e8 00 00 00 00	 call	 _CdeMofine

; 359  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: FILE* fopen(const char* filename, const char* mode)\n"));

  00251	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00258	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11271
  0025f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00264	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11273
  0026b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11272
  00272	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00276	41 b8 67 01 00
	00		 mov	 r8d, 359		; 00000167H
  0027c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00281	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11274
  00288	e8 00 00 00 00	 call	 _CdeMofine

; 360  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: FILE* freopen(const char* filename, const char* mode, FILE * stream)\n"));

  0028d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00294	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11275
  0029b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11277
  002a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11276
  002ae	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  002b2	41 b8 68 01 00
	00		 mov	 r8d, 360		; 00000168H
  002b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11278
  002c4	e8 00 00 00 00	 call	 _CdeMofine

; 361  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: void setbuf(FILE * stream, char* buf)\n"));

  002c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  002d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11279
  002d7	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002dc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11281
  002e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11280
  002ea	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  002ee	41 b8 69 01 00
	00		 mov	 r8d, 361		; 00000169H
  002f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11282
  00300	e8 00 00 00 00	 call	 _CdeMofine

; 362  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int setvbuf(FILE * stream, char* buf, int mode, size_t size)\n"));

  00305	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  0030c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11283
  00313	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00318	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11285
  0031f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11284
  00326	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0032a	41 b8 6a 01 00
	00		 mov	 r8d, 362		; 0000016aH
  00330	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00335	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11286
  0033c	e8 00 00 00 00	 call	 _CdeMofine

; 363  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fprintf(FILE * stream, const char* format, ...)\n"));

  00341	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00348	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11287
  0034f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00354	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11289
  0035b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11288
  00362	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00366	41 b8 6b 01 00
	00		 mov	 r8d, 363		; 0000016bH
  0036c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00371	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11290
  00378	e8 00 00 00 00	 call	 _CdeMofine

; 364  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fscanf(FILE * stream, const char* format, ...)\n"));

  0037d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00384	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11291
  0038b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00390	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11293
  00397	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11292
  0039e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  003a2	41 b8 6c 01 00
	00		 mov	 r8d, 364		; 0000016cH
  003a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11294
  003b4	e8 00 00 00 00	 call	 _CdeMofine

; 365  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int printf(const char* format, ...)\n"));

  003b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11295
  003c0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11297
  003cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11296
  003d3	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  003d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  003e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11298
  003ea	41 b8 6d 01 00
	00		 mov	 r8d, 365		; 0000016dH
  003f0	e8 00 00 00 00	 call	 _CdeMofine

; 366  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int scanf(const char* format, ...)\n"));

  003f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  003fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11299
  00403	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00408	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11301
  0040f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11300
  00416	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0041a	41 b8 6e 01 00
	00		 mov	 r8d, 366		; 0000016eH
  00420	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00425	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11302
  0042c	e8 00 00 00 00	 call	 _CdeMofine

; 367  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int snprintf(char* s, size_t n, const char* format, ...)\n"));

  00431	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00438	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11303
  0043f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00444	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11305
  0044b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11304
  00452	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00456	41 b8 6f 01 00
	00		 mov	 r8d, 367		; 0000016fH
  0045c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00461	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11306
  00468	e8 00 00 00 00	 call	 _CdeMofine

; 368  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int sprintf(char* s, const char* format, ...)\n"));

  0046d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00474	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11307
  0047b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00480	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11309
  00487	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11308
  0048e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00492	41 b8 70 01 00
	00		 mov	 r8d, 368		; 00000170H
  00498	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11310
  004a4	e8 00 00 00 00	 call	 _CdeMofine

; 369  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int vscanf(const char* format, va_list arg) from C99\n"));

  004a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  004b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11311
  004b7	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004bc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11313
  004c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11312
  004ca	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  004ce	41 b8 71 01 00
	00		 mov	 r8d, 369		; 00000171H
  004d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11314
  004e0	e8 00 00 00 00	 call	 _CdeMofine

; 370  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int vsnprintf(char* s, size_t n, const char* format, va_list arg) from C99\n"));

  004e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  004ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11315
  004f3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11317
  004ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11316
  00506	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0050a	41 b8 72 01 00
	00		 mov	 r8d, 370		; 00000172H
  00510	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00515	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11318
  0051c	e8 00 00 00 00	 call	 _CdeMofine

; 371  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int vsscanf(const char* s, const char* format, va_list arg) from C99\n"));

  00521	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00528	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11319
  0052f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00534	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11321
  0053b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11320
  00542	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00546	41 b8 73 01 00
	00		 mov	 r8d, 371		; 00000173H
  0054c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00551	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11322
  00558	e8 00 00 00 00	 call	 _CdeMofine

; 372  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int sscanf(const char* s, const char* format, ...)\n"));

  0055d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00564	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11323
  0056b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00570	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11325
  00577	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11324
  0057e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00582	41 b8 74 01 00
	00		 mov	 r8d, 372		; 00000174H
  00588	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0058d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11326
  00594	e8 00 00 00 00	 call	 _CdeMofine

; 373  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int vfprintf(FILE * stream, const char* format, va_list arg)\n"));

  00599	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11327
  005a0	41 b8 75 01 00
	00		 mov	 r8d, 373		; 00000175H
  005a6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005ab	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11329
  005b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11328
  005b9	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  005bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  005c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11330
  005d0	e8 00 00 00 00	 call	 _CdeMofine

; 374  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int vprintf(const char* format, va_list arg)\n"));

  005d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  005dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11331
  005e3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005e8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11333
  005ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11332
  005f6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  005fa	41 b8 76 01 00
	00		 mov	 r8d, 374		; 00000176H
  00600	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00605	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11334
  0060c	e8 00 00 00 00	 call	 _CdeMofine

; 375  :     CDEMOFINE((MFNINF(1) "Function will     be available for PEI/DXE POST driver: int vsprintf(char* s, const char* format, va_list arg)\n"));

  00611	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00618	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11335
  0061f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00624	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11337
  0062b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11336
  00632	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00636	41 b8 77 01 00
	00		 mov	 r8d, 375		; 00000177H
  0063c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00641	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11338
  00648	e8 00 00 00 00	 call	 _CdeMofine

; 376  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fgetc(FILE * stream)\n"));

  0064d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00654	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11339
  0065b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00660	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11341
  00667	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11340
  0066e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00672	41 b8 78 01 00
	00		 mov	 r8d, 376		; 00000178H
  00678	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0067d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11342
  00684	e8 00 00 00 00	 call	 _CdeMofine

; 377  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: char* fgets(char* s, int n, FILE * stream)\n"));

  00689	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00690	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11343
  00697	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0069c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11345
  006a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11344
  006aa	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  006ae	41 b8 79 01 00
	00		 mov	 r8d, 377		; 00000179H
  006b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11346
  006c0	e8 00 00 00 00	 call	 _CdeMofine

; 378  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fputc(int c, FILE * stream)\n"));

  006c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  006cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11347
  006d3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  006d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11349
  006df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11348
  006e6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  006ea	41 b8 7a 01 00
	00		 mov	 r8d, 378		; 0000017aH
  006f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11350
  006fc	e8 00 00 00 00	 call	 _CdeMofine

; 379  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fputs(const char* s, FILE * stream)\n"));

  00701	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00708	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11351
  0070f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00714	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11353
  0071b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11352
  00722	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00726	41 b8 7b 01 00
	00		 mov	 r8d, 379		; 0000017bH
  0072c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00731	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11354
  00738	e8 00 00 00 00	 call	 _CdeMofine

; 380  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int getc(FILE * stream)\n"));

  0073d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00744	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11355
  0074b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00750	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11357
  00757	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11356
  0075e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00762	41 b8 7c 01 00
	00		 mov	 r8d, 380		; 0000017cH
  00768	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11358
  00774	e8 00 00 00 00	 call	 _CdeMofine

; 381  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int getchar(void)\n"));

  00779	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11359
  00780	41 b8 7d 01 00
	00		 mov	 r8d, 381		; 0000017dH
  00786	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0078b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11361
  00792	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11360
  00799	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0079d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11362
  007a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  007b0	e8 00 00 00 00	 call	 _CdeMofine

; 382  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: char* gets(char* s)\n"));

  007b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  007bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11363
  007c3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  007c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11365
  007cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11364
  007d6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  007da	41 b8 7e 01 00
	00		 mov	 r8d, 382		; 0000017eH
  007e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11366
  007ec	e8 00 00 00 00	 call	 _CdeMofine

; 383  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int putc(int c, FILE * stream)\n"));

  007f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  007f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11367
  007ff	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00804	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11369
  0080b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11368
  00812	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00816	41 b8 7f 01 00
	00		 mov	 r8d, 383		; 0000017fH
  0081c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00821	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11370
  00828	e8 00 00 00 00	 call	 _CdeMofine

; 384  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int putchar(int c)\n"));

  0082d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00834	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11371
  0083b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00840	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11373
  00847	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11372
  0084e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00852	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00858	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0085d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11374
  00864	e8 00 00 00 00	 call	 _CdeMofine

; 385  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int puts(const char* s)\n"));

  00869	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00870	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11375
  00877	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0087c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11377
  00883	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11376
  0088a	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0088e	41 b8 81 01 00
	00		 mov	 r8d, 385		; 00000181H
  00894	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00899	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11378
  008a0	e8 00 00 00 00	 call	 _CdeMofine

; 386  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int ungetc(int c, FILE * stream)\n"));

  008a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  008ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11379
  008b3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  008b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11381
  008bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11380
  008c6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  008ca	41 b8 82 01 00
	00		 mov	 r8d, 386		; 00000182H
  008d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11382
  008dc	e8 00 00 00 00	 call	 _CdeMofine

; 387  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: size_t fread(void* ptr, size_t size, size_t nmemb, FILE * stream)\n"));

  008e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  008e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11383
  008ef	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  008f4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11385
  008fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11384
  00902	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00906	41 b8 83 01 00
	00		 mov	 r8d, 387		; 00000183H
  0090c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00911	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11386
  00918	e8 00 00 00 00	 call	 _CdeMofine

; 388  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE * stream)\n"));

  0091d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00924	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11387
  0092b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00930	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11389
  00937	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11388
  0093e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00942	41 b8 84 01 00
	00		 mov	 r8d, 388		; 00000184H
  00948	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0094d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11390
  00954	e8 00 00 00 00	 call	 _CdeMofine

; 389  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fgetpos(FILE * stream, fpos_t * pos)\n"));

  00959	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00960	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11391
  00967	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0096c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11393
  00973	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11392
  0097a	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0097e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00983	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11394
  0098a	41 b8 85 01 00
	00		 mov	 r8d, 389		; 00000185H
  00990	e8 00 00 00 00	 call	 _CdeMofine

; 390  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fseek(FILE * stream, long int offset, int whence)\n"));

  00995	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  0099c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11395
  009a3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  009a8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11397
  009af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11396
  009b6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  009ba	41 b8 86 01 00
	00		 mov	 r8d, 390		; 00000186H
  009c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11398
  009cc	e8 00 00 00 00	 call	 _CdeMofine

; 391  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int fsetpos(FILE * stream, const fpos_t * pos)\n"));

  009d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  009d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11399
  009df	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  009e4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11401
  009eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11400
  009f2	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  009f6	41 b8 87 01 00
	00		 mov	 r8d, 391		; 00000187H
  009fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a01	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11402
  00a08	e8 00 00 00 00	 call	 _CdeMofine

; 392  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: long int ftell(FILE * stream)\n"));

  00a0d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00a14	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11403
  00a1b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00a20	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11405
  00a27	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11404
  00a2e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00a32	41 b8 88 01 00
	00		 mov	 r8d, 392		; 00000188H
  00a38	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a3d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11406
  00a44	e8 00 00 00 00	 call	 _CdeMofine

; 393  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: void rewind(FILE * stream)\n"));

  00a49	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00a50	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11407
  00a57	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00a5c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11409
  00a63	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11408
  00a6a	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00a6e	41 b8 89 01 00
	00		 mov	 r8d, 393		; 00000189H
  00a74	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a79	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11410
  00a80	e8 00 00 00 00	 call	 _CdeMofine

; 394  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: void clearerr(FILE * stream)\n"));

  00a85	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00a8c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11411
  00a93	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00a98	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11413
  00a9f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11412
  00aa6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00aaa	41 b8 8a 01 00
	00		 mov	 r8d, 394		; 0000018aH
  00ab0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11414
  00abc	e8 00 00 00 00	 call	 _CdeMofine

; 395  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int feof(FILE * stream)\n"));

  00ac1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00ac8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11415
  00acf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ad4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11417
  00adb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11416
  00ae2	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00ae6	41 b8 8b 01 00
	00		 mov	 r8d, 395		; 0000018bH
  00aec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00af1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11418
  00af8	e8 00 00 00 00	 call	 _CdeMofine

; 396  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: int ferror(FILE * stream)\n"));

  00afd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00b04	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11419
  00b0b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00b10	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11421
  00b17	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11420
  00b1e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00b22	41 b8 8c 01 00
	00		 mov	 r8d, 396		; 0000018cH
  00b28	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11422
  00b34	e8 00 00 00 00	 call	 _CdeMofine

; 397  :     CDEMOFINE((MFNINF(1) "Function will not be available for PEI/DXE POST driver: void perror(const char* s)\n"));

  00b39	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00b40	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11423
  00b47	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00b4c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11425
  00b53	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11424
  00b5a	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00b5e	41 b8 8d 01 00
	00		 mov	 r8d, 397		; 0000018dH
  00b64	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b69	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11426
  00b70	e8 00 00 00 00	 call	 _CdeMofine

; 398  : 
; 399  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00b75	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00b7c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11427
  00b83	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00b88	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11429
  00b8f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11428
  00b96	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00b9a	41 b8 8f 01 00
	00		 mov	 r8d, 399		; 0000018fH
  00ba0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ba5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11430
  00bac	e8 00 00 00 00	 call	 _CdeMofine

; 400  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"char* tmpnam(char* s)\"\n"));

  00bb1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00bb8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11431
  00bbf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00bc4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11433
  00bcb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11432
  00bd2	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00bd6	41 b8 90 01 00
	00		 mov	 r8d, 400		; 00000190H
  00bdc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00be1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11434
  00be8	e8 00 00 00 00	 call	 _CdeMofine

; 401  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00bed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00bf4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11435
  00bfb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00c00	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11437
  00c07	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11436
  00c0e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00c12	41 b8 91 01 00
	00		 mov	 r8d, 401		; 00000191H
  00c18	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c1d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11438
  00c24	e8 00 00 00 00	 call	 _CdeMofine
  00c29	8b fe		 mov	 edi, esi
$LL4@main:

; 402  : 
; 403  :     if (1) {
; 404  :         int i;
; 405  :         char* p;
; 406  : 
; 407  :         for (i = 1; i <= 10; i++) {
; 408  :             p = tmpnam(NULL);

  00c2b	33 c9		 xor	 ecx, ecx
  00c2d	e8 00 00 00 00	 call	 tmpnam

; 409  :             CDEMOFINE((MFNINF(1) "TMPNAM # %2d: %s\n", i, p));

  00c32	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00c39	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11442
  00c40	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00c45	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11443
  00c4c	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00c50	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11440
  00c57	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00c5c	41 b8 99 01 00
	00		 mov	 r8d, 409		; 00000199H
  00c62	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11441
  00c69	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00c6d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c72	e8 00 00 00 00	 call	 _CdeMofine
  00c77	03 fe		 add	 edi, esi
  00c79	83 ff 0a	 cmp	 edi, 10
  00c7c	7e ad		 jle	 SHORT $LL4@main

; 410  :         }
; 411  :     }
; 412  : 
; 413  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00c7e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00c85	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11444
  00c8c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00c91	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11446
  00c98	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11445
  00c9f	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00ca3	41 b8 9d 01 00
	00		 mov	 r8d, 413		; 0000019dH
  00ca9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11447
  00cb5	e8 00 00 00 00	 call	 _CdeMofine

; 414  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"int printf(const char * format, ...)\"\n"));

  00cba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00cc1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11448
  00cc8	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ccd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11450
  00cd4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11449
  00cdb	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00cdf	41 b8 9e 01 00
	00		 mov	 r8d, 414		; 0000019eH
  00ce5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11451
  00cf1	e8 00 00 00 00	 call	 _CdeMofine

; 415  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"int sprintf(char * s ,const char * format, ...)\"\n"));

  00cf6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00cfd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11452
  00d04	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00d09	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11454
  00d10	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11453
  00d17	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00d1b	41 b8 9f 01 00
	00		 mov	 r8d, 415		; 0000019fH
  00d21	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11455
  00d2d	e8 00 00 00 00	 call	 _CdeMofine

; 416  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00d32	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00d39	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11456
  00d40	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00d45	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11458
  00d4c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11457
  00d53	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00d57	41 b8 a0 01 00
	00		 mov	 r8d, 416		; 000001a0H
  00d5d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d62	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11459
  00d69	e8 00 00 00 00	 call	 _CdeMofine

; 417  :     if (1) {
; 418  :         int n;
; 419  :         printf("%s(%d): printf() -> Welcome, to the jungle... \n", __FILE__, __LINE__);

  00d6e	41 b8 a3 01 00
	00		 mov	 r8d, 419		; 000001a3H
  00d74	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11461
  00d7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG11462
  00d82	e8 00 00 00 00	 call	 printf

; 420  :         memset(b, 'U' /*0x55*/, ELC(b)); // clear buffer

  00d87	41 bf 40 00 00
	00		 mov	 r15d, 64		; 00000040H
  00d8d	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  00d91	45 8b c7	 mov	 r8d, r15d
  00d94	41 8d 57 15	 lea	 edx, QWORD PTR [r15+21]
  00d98	e8 00 00 00 00	 call	 memset

; 421  :         n = sprintf(&b[0], "sprintf() -> Welcome, to the jungle... \n");

  00d9d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11463
  00da4	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  00da8	e8 00 00 00 00	 call	 sprintf

; 422  :         CDEMOFINE((MFNINF(1) "Chars written: %d, %s\n", n, b));

  00dad	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  00db1	41 b8 a6 01 00
	00		 mov	 r8d, 422		; 000001a6H
  00db7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00dbc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11466
  00dc3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00dca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11467
  00dd1	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00dd5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11464
  00ddc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00de1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11465
  00de8	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00dec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00df1	e8 00 00 00 00	 call	 _CdeMofine

; 423  :         UniDump(hexparms, sizeof(b), (unsigned long long) & b[0], (unsigned long long(*)(unsigned long long)) & GetMem8, WriteString);

  00df6	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:WriteString
  00dfd	41 8b d7	 mov	 edx, r15d
  00e00	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:GetMem8
  00e07	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00e0c	4c 8d 45 f7	 lea	 r8, QWORD PTR b$[rbp-185]
  00e10	8b cb		 mov	 ecx, ebx
  00e12	e8 00 00 00 00	 call	 UniDump

; 424  :     }
; 425  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00e17	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00e1e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11468
  00e25	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00e2a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11470
  00e31	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11469
  00e38	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00e3c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e41	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11471
  00e48	41 b8 a9 01 00
	00		 mov	 r8d, 425		; 000001a9H
  00e4e	e8 00 00 00 00	 call	 _CdeMofine

; 426  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"int snprintf(char* s, size_t n, const char* format, ...)\"\n"));

  00e53	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00e5a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11472
  00e61	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00e66	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11474
  00e6d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11473
  00e74	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00e78	41 b8 aa 01 00
	00		 mov	 r8d, 426		; 000001aaH
  00e7e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e83	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11475
  00e8a	e8 00 00 00 00	 call	 _CdeMofine

; 427  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00e8f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00e96	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11476
  00e9d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ea2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11478
  00ea9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11477
  00eb0	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00eb4	41 b8 ab 01 00
	00		 mov	 r8d, 427		; 000001abH
  00eba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ebf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11479
  00ec6	e8 00 00 00 00	 call	 _CdeMofine
  00ecb	8b fb		 mov	 edi, ebx
$LL7@main:

; 428  :     if (1) {
; 429  :         int i,n;
; 430  : 
; 431  :         for (i = 0; i < sizeof("snprintf()"); i++) {
; 432  :             memset(b, 'U' /*0x55*/, ELC(b)); // clear buffer

  00ecd	4d 8b c7	 mov	 r8, r15
  00ed0	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  00ed4	ba 55 00 00 00	 mov	 edx, 85			; 00000055H
  00ed9	e8 00 00 00 00	 call	 memset

; 433  :             b[sizeof(b) - 1] = '\0';
; 434  :             n = snprintf(b, (size_t)i, "snprintf()");

  00ede	48 63 d7	 movsxd	 rdx, edi
  00ee1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG11481
  00ee8	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  00eec	88 5d 36	 mov	 BYTE PTR b$[rbp-122], bl
  00eef	e8 00 00 00 00	 call	 snprintf

; 435  :             CDEMOFINE((MFNINF(1) "cnt = %2d, n = %2d: %s.\n", i, n, b));

  00ef4	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  00ef8	41 b8 b3 01 00
	00		 mov	 r8d, 435		; 000001b3H
  00efe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f03	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11484
  00f0a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00f11	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11485
  00f18	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00f1c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11482
  00f23	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00f27	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00f2c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11483
  00f33	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00f37	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f3c	e8 00 00 00 00	 call	 _CdeMofine

; 436  :             UniDump(hexparms, sizeof(b), (unsigned long long) & b[0], (unsigned long long(*)(unsigned long long)) & GetMem8, WriteString);

  00f41	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:GetMem8
  00f48	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00f4d	4c 8d 45 f7	 lea	 r8, QWORD PTR b$[rbp-185]
  00f51	41 8b d7	 mov	 edx, r15d
  00f54	8b cb		 mov	 ecx, ebx
  00f56	e8 00 00 00 00	 call	 UniDump
  00f5b	03 fe		 add	 edi, esi
  00f5d	83 ff 0b	 cmp	 edi, 11
  00f60	0f 82 67 ff ff
	ff		 jb	 $LL7@main

; 437  :         }
; 438  : 
; 439  :     }
; 440  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00f66	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00f6d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11486
  00f74	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00f79	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11488
  00f80	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11487
  00f87	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00f8b	41 b8 b8 01 00
	00		 mov	 r8d, 440		; 000001b8H
  00f91	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11489
  00f9d	e8 00 00 00 00	 call	 _CdeMofine

; 441  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"int vsnprintf(char* s, size_t n, const char* format, va_list ap)\"\n"));

  00fa2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00fa9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11490
  00fb0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00fb5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11492
  00fbc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11491
  00fc3	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  00fc7	41 b8 b9 01 00
	00		 mov	 r8d, 441		; 000001b9H
  00fcd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fd2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11493
  00fd9	e8 00 00 00 00	 call	 _CdeMofine

; 442  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  00fde	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  00fe5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11494
  00fec	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ff1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11496
  00ff8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11495
  00fff	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  01003	41 b8 ba 01 00
	00		 mov	 r8d, 442		; 000001baH
  01009	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0100e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11497
  01015	e8 00 00 00 00	 call	 _CdeMofine
  0101a	8b fb		 mov	 edi, ebx
$LL10@main:

; 443  :     if (1) {
; 444  :         int i, n;
; 445  : 
; 446  :         for (i = 0; i < sizeof("vsnprintf()\n"); i++) {
; 447  :             memset(b, 'U' /*0x55*/, ELC(b)); // clear buffer

  0101c	4d 8b c7	 mov	 r8, r15
  0101f	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  01023	ba 55 00 00 00	 mov	 edx, 85			; 00000055H
  01028	e8 00 00 00 00	 call	 memset

; 448  :             b[sizeof(b) - 1] = '\0';
; 449  :             n = vsnprintfwrapper(b, (size_t)i, "vsnprintf()\n");

  0102d	48 63 d7	 movsxd	 rdx, edi
  01030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG11499
  01037	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  0103b	88 5d 36	 mov	 BYTE PTR b$[rbp-122], bl
  0103e	e8 00 00 00 00	 call	 vsnprintfwrapper

; 450  :             CDEMOFINE((MFNINF(1) "cnt = %2d, n = %2d: %s.\n", i, n, b));

  01043	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  01047	41 b8 c2 01 00
	00		 mov	 r8d, 450		; 000001c2H
  0104d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11502
  01059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11503
  01067	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0106b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11500
  01072	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  01076	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0107b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11501
  01082	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  01086	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0108b	e8 00 00 00 00	 call	 _CdeMofine

; 451  :             UniDump(hexparms, sizeof(b), (unsigned long long) & b[0], (unsigned long long(*)(unsigned long long)) & GetMem8, WriteString);

  01090	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:GetMem8
  01097	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0109c	4c 8d 45 f7	 lea	 r8, QWORD PTR b$[rbp-185]
  010a0	41 8b d7	 mov	 edx, r15d
  010a3	8b cb		 mov	 ecx, ebx
  010a5	e8 00 00 00 00	 call	 UniDump
  010aa	03 fe		 add	 edi, esi
  010ac	83 ff 0d	 cmp	 edi, 13
  010af	0f 82 67 ff ff
	ff		 jb	 $LL10@main

; 452  :         }
; 453  : 
; 454  :     }
; 455  :     
; 456  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  010b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  010bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11504
  010c3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  010c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11506
  010cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11505
  010d6	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  010da	41 b8 c8 01 00
	00		 mov	 r8d, 456		; 000001c8H
  010e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11507
  010ec	e8 00 00 00 00	 call	 _CdeMofine

; 457  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"int vsprintf(char* s, const char* format, va_list arg)\"\n"));

  010f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  010f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11508
  010ff	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01104	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11510
  0110b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11509
  01112	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  01116	41 b8 c9 01 00
	00		 mov	 r8d, 457		; 000001c9H
  0111c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11511
  01128	e8 00 00 00 00	 call	 _CdeMofine

; 458  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  0112d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01134	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11512
  0113b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01140	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11514
  01147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11513
  0114e	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  01152	41 b8 ca 01 00
	00		 mov	 r8d, 458		; 000001caH
  01158	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0115d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11515
  01164	e8 00 00 00 00	 call	 _CdeMofine

; 459  :     if (1) {
; 460  : 
; 461  :         memset(b, 'U' /*0x55*/, ELC(b)); // clear buffer

  01169	4d 8b c7	 mov	 r8, r15
  0116c	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  01170	ba 55 00 00 00	 mov	 edx, 85			; 00000055H
  01175	e8 00 00 00 00	 call	 memset

; 462  :         b[sizeof(b) - 1] = '\0';
; 463  :         vsprintfwrapper(b, "vsprintf() -> Welcome, to the jungle... \n");

  0117a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11517
  01181	88 5d 36	 mov	 BYTE PTR b$[rbp-122], bl
  01184	48 8d 4d f7	 lea	 rcx, QWORD PTR b$[rbp-185]
  01188	e8 00 00 00 00	 call	 vsprintfwrapper

; 464  :         CDEMOFINE((MFNINF(1) "%s\n", b));

  0118d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01194	48 8d 45 f7	 lea	 rax, QWORD PTR b$[rbp-185]
  01198	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0119d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11520
  011a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11518
  011ab	41 b8 d0 01 00
	00		 mov	 r8d, 464		; 000001d0H
  011b1	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  011b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11521
  011bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11519
  011c4	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  011c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011cd	e8 00 00 00 00	 call	 _CdeMofine

; 465  : 
; 466  :     }
; 467  : 
; 468  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  011d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  011d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11522
  011e0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  011e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11524
  011ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11523
  011f3	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  011f7	41 b8 d4 01 00
	00		 mov	 r8d, 468		; 000001d4H
  011fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01202	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11525
  01209	e8 00 00 00 00	 call	 _CdeMofine

; 469  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"int vprintf(const char* format, va_list arg)\"\n"));

  0120e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01215	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11526
  0121c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01221	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11528
  01228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11527
  0122f	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  01233	41 b8 d5 01 00
	00		 mov	 r8d, 469		; 000001d5H
  01239	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0123e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11529
  01245	e8 00 00 00 00	 call	 _CdeMofine

; 470  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  0124a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01251	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11530
  01258	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0125d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11532
  01264	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11531
  0126b	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0126f	41 b8 d6 01 00
	00		 mov	 r8d, 470		; 000001d6H
  01275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0127a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11533
  01281	e8 00 00 00 00	 call	 _CdeMofine

; 471  :     if (1) {
; 472  : 
; 473  :         vprintfwrapper("vprintf() -> Welcome, to the jungle... \n");

  01286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG11535
  0128d	e8 00 00 00 00	 call	 vprintfwrapper

; 474  : 
; 475  :     }
; 476  : 
; 477  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  01292	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01299	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11536
  012a0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  012a5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11538
  012ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11537
  012b3	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  012b7	41 b8 dd 01 00
	00		 mov	 r8d, 477		; 000001ddH
  012bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11539
  012c9	e8 00 00 00 00	 call	 _CdeMofine

; 478  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"sscanf(const char* s, const char* format, ...)\"\n"));

  012ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  012d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11540
  012dc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  012e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11542
  012e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11541
  012ef	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  012f3	41 b8 de 01 00
	00		 mov	 r8d, 478		; 000001deH
  012f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11543
  01305	e8 00 00 00 00	 call	 _CdeMofine

; 479  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  0130a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01311	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11544
  01318	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0131d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11546
  01324	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11545
  0132b	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0132f	41 b8 df 01 00
	00		 mov	 r8d, 479		; 000001dfH
  01335	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0133a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11547
  01341	e8 00 00 00 00	 call	 _CdeMofine

; 480  :     if (1) {
; 481  :         int no1 = -1;
; 482  :         int no2 = -1;
; 483  :         int no3 = -1;
; 484  :         int token = -1;
; 485  :         char str1[8] = { 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 };
; 486  :         char str2[8] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };
; 487  :         char buffer[] = "1 22 333 STR1   STR2";

  01346	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR $SG11549+16

; 488  : 
; 489  :         token = sscanf(buffer, "%d %d %d %s %s", &no1, &no2, &no3, &str1[0], &str2[0]);

  0134c	4c 8d 4d 7f	 lea	 r9, QWORD PTR no2$12[rbp-185]
  01350	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR $SG11549
  01357	89 45 df	 mov	 DWORD PTR buffer$8[rbp-169], eax
  0135a	4c 8d 45 c7	 lea	 r8, QWORD PTR no1$6[rbp-185]
  0135e	8a 05 14 00 00
	00		 mov	 al, BYTE PTR $SG11549+20
  01364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11550
  0136b	88 45 e3	 mov	 BYTE PTR buffer$8[rbp-165], al
  0136e	48 8d 4d cf	 lea	 rcx, QWORD PTR buffer$8[rbp-185]
  01372	83 cb ff	 or	 ebx, -1
  01375	c7 45 bf 55 55
	55 55		 mov	 DWORD PTR str1$4[rbp-185], 1431655765 ; 55555555H
  0137c	48 8d 45 b7	 lea	 rax, QWORD PTR str2$2[rbp-185]
  01380	89 5d c7	 mov	 DWORD PTR no1$6[rbp-185], ebx
  01383	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01388	48 8d 45 bf	 lea	 rax, QWORD PTR str1$4[rbp-185]
  0138c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01391	48 8d 45 77	 lea	 rax, QWORD PTR no3$10[rbp-185]
  01395	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0139a	89 5d 7f	 mov	 DWORD PTR no2$12[rbp-185], ebx
  0139d	89 5d 77	 mov	 DWORD PTR no3$10[rbp-185], ebx
  013a0	c7 45 c3 55 55
	55 55		 mov	 DWORD PTR str1$4[rbp-181], 1431655765 ; 55555555H
  013a7	c7 45 b7 aa aa
	aa aa		 mov	 DWORD PTR str2$2[rbp-185], -1431655766 ; aaaaaaaaH
  013ae	c7 45 bb aa aa
	aa aa		 mov	 DWORD PTR str2$2[rbp-181], -1431655766 ; aaaaaaaaH
  013b5	0f 11 45 cf	 movups	 XMMWORD PTR buffer$8[rbp-185], xmm0
  013b9	e8 00 00 00 00	 call	 sscanf

; 490  : 
; 491  :         CDEMOFINE((MFNINF(1) "token = %d, no1 %d, no2 %d, no3 %d, str1 %s, str2 %s\n", token, no1, no2, no3, str1, str2));

  013be	48 8d 4d b7	 lea	 rcx, QWORD PTR str2$2[rbp-185]
  013c2	41 b8 eb 01 00
	00		 mov	 r8d, 491		; 000001ebH
  013c8	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  013cd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11553
  013d4	48 8d 4d bf	 lea	 rcx, QWORD PTR str1$4[rbp-185]
  013d8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  013dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11554
  013e4	8b 4d 77	 mov	 ecx, DWORD PTR no3$10[rbp-185]
  013e7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  013eb	8b 4d 7f	 mov	 ecx, DWORD PTR no2$12[rbp-185]
  013ee	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  013f2	8b 4d c7	 mov	 ecx, DWORD PTR no1$6[rbp-185]
  013f5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01400	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  01404	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11551
  0140b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01410	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11552
  01417	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0141b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01420	e8 00 00 00 00	 call	 _CdeMofine

; 492  : 
; 493  : 
; 494  :     }
; 495  : 
; 496  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  01425	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11555
  0142c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01431	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11556
  01438	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  0143c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01443	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11557
  0144a	41 b8 f0 01 00
	00		 mov	 r8d, 496		; 000001f0H
  01450	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01455	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11558
  0145c	e8 00 00 00 00	 call	 _CdeMofine

; 497  :     CDEMOFINE((MFNINF(1) "### Demonstrating \"vsscanf(const char* s, const char* format, va_list arg)\"\n"));

  01461	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01468	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11559
  0146f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01474	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11561
  0147b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11560
  01482	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  01486	41 b8 f1 01 00
	00		 mov	 r8d, 497		; 000001f1H
  0148c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01491	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11562
  01498	e8 00 00 00 00	 call	 _CdeMofine

; 498  :     CDEMOFINE((MFNINF(1) "##################################################################\n"));

  0149d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  014a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11563
  014ab	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  014b0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11565
  014b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11564
  014be	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  014c2	41 b8 f2 01 00
	00		 mov	 r8d, 498		; 000001f2H
  014c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11566
  014d4	e8 00 00 00 00	 call	 _CdeMofine

; 499  :     if (1) {
; 500  :         int no1 = -1;
; 501  :         int no2 = -1;
; 502  :         int no3 = -1;
; 503  :         int token = -1;
; 504  :         char str1[8] = { 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 };
; 505  :         char str2[8] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };
; 506  :         char buffer[] = "111 22 3 STRing   STRINg";

  014d9	8a 05 18 00 00
	00		 mov	 al, BYTE PTR $SG11568+24

; 507  : 
; 508  :         token = vsscanfwrapper(buffer, "%d %d %d %s %s", &no1, &no2, &no3, &str1[0], &str2[0]);

  014df	4c 8d 4d 7f	 lea	 r9, QWORD PTR no2$11[rbp-185]
  014e3	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR $SG11568
  014ea	4c 8d 45 c7	 lea	 r8, QWORD PTR no1$5[rbp-185]
  014ee	88 45 e7	 mov	 BYTE PTR buffer$7[rbp-161], al
  014f1	f2 0f 10 0d 10
	00 00 00	 movsd	 xmm1, QWORD PTR $SG11568+16
  014f9	48 8d 45 bf	 lea	 rax, QWORD PTR str2$3[rbp-185]
  014fd	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01502	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11569
  01509	48 8d 45 b7	 lea	 rax, QWORD PTR str1$1[rbp-185]
  0150d	89 5d c7	 mov	 DWORD PTR no1$5[rbp-185], ebx
  01510	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01515	48 8d 4d cf	 lea	 rcx, QWORD PTR buffer$7[rbp-185]
  01519	48 8d 45 77	 lea	 rax, QWORD PTR no3$9[rbp-185]
  0151d	89 5d 7f	 mov	 DWORD PTR no2$11[rbp-185], ebx
  01520	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01525	89 5d 77	 mov	 DWORD PTR no3$9[rbp-185], ebx
  01528	c7 45 b7 55 55
	55 55		 mov	 DWORD PTR str1$1[rbp-185], 1431655765 ; 55555555H
  0152f	c7 45 bb 55 55
	55 55		 mov	 DWORD PTR str1$1[rbp-181], 1431655765 ; 55555555H
  01536	c7 45 bf aa aa
	aa aa		 mov	 DWORD PTR str2$3[rbp-185], -1431655766 ; aaaaaaaaH
  0153d	c7 45 c3 aa aa
	aa aa		 mov	 DWORD PTR str2$3[rbp-181], -1431655766 ; aaaaaaaaH
  01544	0f 11 45 cf	 movups	 XMMWORD PTR buffer$7[rbp-185], xmm0
  01548	f2 0f 11 4d df	 movsd	 QWORD PTR buffer$7[rbp-169], xmm1
  0154d	e8 00 00 00 00	 call	 vsscanfwrapper

; 509  : 
; 510  :         CDEMOFINE((MFNINF(1) "token = %d, no1 %d, no2 %d, no3 %d, str1 %s, str2 %s\n", token, no1, no2, no3, str1, str2));

  01552	48 8d 4d bf	 lea	 rcx, QWORD PTR str2$3[rbp-185]
  01556	41 b8 fe 01 00
	00		 mov	 r8d, 510		; 000001feH
  0155c	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01561	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG11572
  01568	48 8d 4d b7	 lea	 rcx, QWORD PTR str1$1[rbp-185]
  0156c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01571	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11573
  01578	8b 4d 77	 mov	 ecx, DWORD PTR no3$9[rbp-185]
  0157b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0157f	8b 4d 7f	 mov	 ecx, DWORD PTR no2$11[rbp-185]
  01582	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01586	8b 4d c7	 mov	 ecx, DWORD PTR no1$5[rbp-185]
  01589	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0158d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gEfiCallerBaseName
  01594	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  01598	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11570
  0159f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  015a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11571
  015ab	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  015af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015b4	e8 00 00 00 00	 call	 _CdeMofine

; 511  :     }
; 512  : }

  015b9	48 8b 9c 24 20
	01 00 00	 mov	 rbx, QWORD PTR [rsp+288]
  015c1	33 c0		 xor	 eax, eax
  015c3	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  015ca	41 5f		 pop	 r15
  015cc	41 5d		 pop	 r13
  015ce	5f		 pop	 rdi
  015cf	5e		 pop	 rsi
  015d0	5d		 pop	 rbp
  015d1	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT vsscanfwrapper
_TEXT	SEGMENT
s$ = 48
format$ = 56
vsscanfwrapper PROC					; COMDAT

; 331  : int vsscanfwrapper(const char* s, const char* format, ...) {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 332  :     va_list ap;
; 333  :     int nRet;
; 334  : 
; 335  :     va_start(ap, format);

  00013	4c 8d 40 18	 lea	 r8, QWORD PTR [rax+24]

; 336  :     nRet = vsscanf(s, format, ap);

  00017	e8 00 00 00 00	 call	 vsscanf

; 337  :     va_end(ap);
; 338  :     return nRet;
; 339  : 
; 340  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
vsscanfwrapper ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT vprintfwrapper
_TEXT	SEGMENT
format$ = 48
vprintfwrapper PROC					; COMDAT

; 321  : int vprintfwrapper(const char* format, ...) {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00007	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000b	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000f	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00013	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 322  :     va_list ap;
; 323  :     int nRet;
; 324  : 
; 325  :     va_start(ap, format);

  00017	48 8d 50 10	 lea	 rdx, QWORD PTR [rax+16]

; 326  :     nRet = vprintf(format, ap);

  0001b	e8 00 00 00 00	 call	 vprintf

; 327  :     va_end(ap);
; 328  :     return nRet;
; 329  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
vprintfwrapper ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT vsprintfwrapper
_TEXT	SEGMENT
s$ = 48
format$ = 56
vsprintfwrapper PROC					; COMDAT

; 311  : int vsprintfwrapper(char* s, const char* format, ...) {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 312  :     va_list ap;
; 313  :     int nRet;
; 314  : 
; 315  :     va_start(ap, format);

  00013	4c 8d 40 18	 lea	 r8, QWORD PTR [rax+24]

; 316  :     nRet = vsprintf(s, format, ap);

  00017	e8 00 00 00 00	 call	 vsprintf

; 317  :     va_end(ap);
; 318  :     return nRet;
; 319  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
vsprintfwrapper ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT vsnprintfwrapper
_TEXT	SEGMENT
s$ = 48
n$ = 56
format$ = 64
vsnprintfwrapper PROC					; COMDAT

; 301  : int vsnprintfwrapper(char* s, size_t n, const char* format, ...) {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 302  :     va_list ap;
; 303  :     int nRet;
; 304  : 
; 305  :     va_start(ap, format);

  0000e	4c 8d 4c 24 48	 lea	 r9, QWORD PTR format$[rsp+8]

; 306  :     nRet = vsnprintf(s, n, format, ap);

  00013	e8 00 00 00 00	 call	 vsnprintf

; 307  :     va_end(ap);
; 308  :     return nRet;
; 309  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
vsnprintfwrapper ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT PrintAscii
_TEXT	SEGMENT
qwLit2Big$ = 80
pBuffer$ = 80
elmsize$ = 88
cToPrint$ = 96
pTextLineBuf$ = 104
PrintAscii PROC						; COMDAT

; 138  : static int PrintAscii(char* pBuffer, unsigned elmsize, unsigned cToPrint, unsigned char* pTextLineBuf) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	49 8b e9	 mov	 rbp, r9
  0001f	41 8b f0	 mov	 esi, r8d
  00022	4c 8b e1	 mov	 r12, rcx

; 139  :     unsigned char* pb = (unsigned char*)&pBuffer[0];
; 140  :     unsigned short* pw = (unsigned short*)&pBuffer[0];
; 141  :     unsigned int* pdw = (unsigned int*)&pBuffer[0];
; 142  :     unsigned long long* pqw = (unsigned long long*) & pBuffer[0];
; 143  :     unsigned long long qwLit2Big;/*!< little endian to big endian translation buffer*/
; 144  :     unsigned char* pLit2Big = (unsigned char*)&qwLit2Big;
; 145  :     unsigned j;
; 146  : 
; 147  : #define PRINTREVERSE for (k = elmsize - 1 ; k != (unsigned)-1 ; k--){\
; 148  :                              sprintf(&pTextLineBuf[strlen(pTextLineBuf)],"%c", isalnum(pLit2Big[k]) ? 0xFF & pLit2Big[k] : '.'); \
; 149  :                          }\
; 150  :                          if (elmsize - 1){/*!< add space between ASCII char, except in 8-bit format*/\
; 151  :                              sprintf(&pTextLineBuf[strlen(pTextLineBuf)]," ");\
; 152  :                          }// END PRINTREVERSE
; 153  : 
; 154  :     switch (elmsize) {

  00025	83 ea 01	 sub	 edx, 1
  00028	0f 84 ad 01 00
	00		 je	 $LN28@PrintAscii
  0002e	83 ea 01	 sub	 edx, 1
  00031	0f 84 20 01 00
	00		 je	 $LN30@PrintAscii
  00037	83 ea 02	 sub	 edx, 2
  0003a	0f 84 91 00 00
	00		 je	 $LN32@PrintAscii
  00040	83 fa 04	 cmp	 edx, 4
  00043	0f 85 ea 01 00
	00		 jne	 $LN5@PrintAscii

; 176  : 
; 177  :         case sizeof(long long) :
; 178  :             for (j = 0; j < cToPrint; j += elmsize) {

  00049	45 33 ff	 xor	 r15d, r15d
  0004c	45 85 c0	 test	 r8d, r8d
  0004f	0f 84 de 01 00
	00		 je	 $LN5@PrintAscii
  00055	41 83 ce ff	 or	 r14d, -1		; ffffffffH
$LL24@PrintAscii:

; 179  :                 *((unsigned long long*)pLit2Big) = 0xFFFFFFFFFFFFFFFFLL & pqw[j / elmsize];

  00059	41 8b c7	 mov	 eax, r15d

; 180  :                 PRINTREVERSE;

  0005c	41 bd 07 00 00
	00		 mov	 r13d, 7
  00062	48 c1 e8 03	 shr	 rax, 3
  00066	49 8b 04 c4	 mov	 rax, QWORD PTR [r12+rax*8]
  0006a	48 89 44 24 50	 mov	 QWORD PTR qwLit2Big$[rsp], rax
$LL27@PrintAscii:
  0006f	41 8b c5	 mov	 eax, r13d
  00072	0f b6 5c 04 50	 movzx	 ebx, BYTE PTR qwLit2Big$[rsp+rax]
  00077	8b cb		 mov	 ecx, ebx
  00079	e8 00 00 00 00	 call	 isalnum
  0007e	85 c0		 test	 eax, eax
  00080	bf 2e 00 00 00	 mov	 edi, 46			; 0000002eH
  00085	48 8b cd	 mov	 rcx, rbp
  00088	0f 45 fb	 cmovne	 edi, ebx
  0008b	e8 00 00 00 00	 call	 strlen
  00090	44 8b c7	 mov	 r8d, edi
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11056
  0009a	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  0009e	e8 00 00 00 00	 call	 sprintf
  000a3	45 03 ee	 add	 r13d, r14d
  000a6	45 3b ee	 cmp	 r13d, r14d
  000a9	75 c4		 jne	 SHORT $LL27@PrintAscii
  000ab	48 8b cd	 mov	 rcx, rbp
  000ae	e8 00 00 00 00	 call	 strlen
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11058
  000ba	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  000be	e8 00 00 00 00	 call	 sprintf
  000c3	41 83 c7 08	 add	 r15d, 8
  000c7	44 3b fe	 cmp	 r15d, esi
  000ca	72 8d		 jb	 SHORT $LL24@PrintAscii
  000cc	e9 62 01 00 00	 jmp	 $LN5@PrintAscii
$LN32@PrintAscii:

; 169  : 
; 170  :         case sizeof(int) :
; 171  :             for (j = 0; j < cToPrint; j += elmsize) {

  000d1	45 33 ff	 xor	 r15d, r15d
  000d4	85 f6		 test	 esi, esi
  000d6	0f 84 57 01 00
	00		 je	 $LN5@PrintAscii
  000dc	41 83 ce ff	 or	 r14d, -1		; ffffffffH
$LL18@PrintAscii:

; 172  :                 *((unsigned int*)pLit2Big) = 0xFFFFFFFF & pdw[j / elmsize];

  000e0	41 8b c7	 mov	 eax, r15d

; 173  :                 PRINTREVERSE;

  000e3	41 bd 03 00 00
	00		 mov	 r13d, 3
  000e9	48 c1 e8 02	 shr	 rax, 2
  000ed	41 8b 04 84	 mov	 eax, DWORD PTR [r12+rax*4]
  000f1	89 44 24 50	 mov	 DWORD PTR qwLit2Big$[rsp], eax
$LL21@PrintAscii:
  000f5	41 8b c5	 mov	 eax, r13d
  000f8	0f b6 5c 04 50	 movzx	 ebx, BYTE PTR qwLit2Big$[rsp+rax]
  000fd	8b cb		 mov	 ecx, ebx
  000ff	e8 00 00 00 00	 call	 isalnum
  00104	85 c0		 test	 eax, eax
  00106	bf 2e 00 00 00	 mov	 edi, 46			; 0000002eH
  0010b	48 8b cd	 mov	 rcx, rbp
  0010e	0f 45 fb	 cmovne	 edi, ebx
  00111	e8 00 00 00 00	 call	 strlen
  00116	44 8b c7	 mov	 r8d, edi
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11052
  00120	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  00124	e8 00 00 00 00	 call	 sprintf
  00129	45 03 ee	 add	 r13d, r14d
  0012c	45 3b ee	 cmp	 r13d, r14d
  0012f	75 c4		 jne	 SHORT $LL21@PrintAscii
  00131	48 8b cd	 mov	 rcx, rbp
  00134	e8 00 00 00 00	 call	 strlen
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11054
  00140	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  00144	e8 00 00 00 00	 call	 sprintf
  00149	41 83 c7 04	 add	 r15d, 4
  0014d	44 3b fe	 cmp	 r15d, esi
  00150	72 8e		 jb	 SHORT $LL18@PrintAscii

; 174  :             }
; 175  :         break;

  00152	e9 dc 00 00 00	 jmp	 $LN5@PrintAscii
$LN30@PrintAscii:

; 160  :             }
; 161  :         break;
; 162  : 
; 163  :         case sizeof(short) :
; 164  :             for (j = 0; j < cToPrint; j += elmsize) {

  00157	45 33 ff	 xor	 r15d, r15d
  0015a	85 f6		 test	 esi, esi
  0015c	0f 84 d1 00 00
	00		 je	 $LN5@PrintAscii
  00162	41 83 ce ff	 or	 r14d, -1		; ffffffffH
$LL12@PrintAscii:

; 165  :                 *((unsigned short*)pLit2Big) = 0xFFFF & pw[j / elmsize];

  00166	41 8b c7	 mov	 eax, r15d

; 166  :                 PRINTREVERSE;

  00169	41 bd 01 00 00
	00		 mov	 r13d, 1
  0016f	48 d1 e8	 shr	 rax, 1
  00172	41 0f b7 04 44	 movzx	 eax, WORD PTR [r12+rax*2]
  00177	66 89 44 24 50	 mov	 WORD PTR qwLit2Big$[rsp], ax
$LL15@PrintAscii:
  0017c	41 8b c5	 mov	 eax, r13d
  0017f	0f b6 5c 04 50	 movzx	 ebx, BYTE PTR qwLit2Big$[rsp+rax]
  00184	8b cb		 mov	 ecx, ebx
  00186	e8 00 00 00 00	 call	 isalnum
  0018b	85 c0		 test	 eax, eax
  0018d	bf 2e 00 00 00	 mov	 edi, 46			; 0000002eH
  00192	48 8b cd	 mov	 rcx, rbp
  00195	0f 45 fb	 cmovne	 edi, ebx
  00198	e8 00 00 00 00	 call	 strlen
  0019d	44 8b c7	 mov	 r8d, edi
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11048
  001a7	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  001ab	e8 00 00 00 00	 call	 sprintf
  001b0	45 03 ee	 add	 r13d, r14d
  001b3	45 3b ee	 cmp	 r13d, r14d
  001b6	75 c4		 jne	 SHORT $LL15@PrintAscii
  001b8	48 8b cd	 mov	 rcx, rbp
  001bb	e8 00 00 00 00	 call	 strlen
  001c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11050
  001c7	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  001cb	e8 00 00 00 00	 call	 sprintf
  001d0	41 83 c7 02	 add	 r15d, 2
  001d4	44 3b fe	 cmp	 r15d, esi
  001d7	72 8d		 jb	 SHORT $LL12@PrintAscii

; 167  :             }
; 168  :         break;

  001d9	eb 58		 jmp	 SHORT $LN5@PrintAscii
$LN28@PrintAscii:

; 155  :         unsigned k;
; 156  :         case sizeof(char) :
; 157  :             for (j = 0; j < cToPrint; j += elmsize) {

  001db	45 33 ff	 xor	 r15d, r15d
  001de	85 f6		 test	 esi, esi
  001e0	74 51		 je	 SHORT $LN5@PrintAscii
  001e2	41 83 ce ff	 or	 r14d, -1		; ffffffffH
$LL6@PrintAscii:

; 158  :                 *((unsigned char*)pLit2Big) = 0xFF & pb[j / elmsize];

  001e6	43 8a 0c 27	 mov	 cl, BYTE PTR [r15+r12]

; 159  :                 PRINTREVERSE;

  001ea	45 33 ed	 xor	 r13d, r13d
  001ed	88 4c 24 50	 mov	 BYTE PTR qwLit2Big$[rsp], cl
$LL9@PrintAscii:
  001f1	42 0f b6 5c 2c
	50		 movzx	 ebx, BYTE PTR qwLit2Big$[rsp+r13]
  001f7	8b cb		 mov	 ecx, ebx
  001f9	e8 00 00 00 00	 call	 isalnum
  001fe	85 c0		 test	 eax, eax
  00200	bf 2e 00 00 00	 mov	 edi, 46			; 0000002eH
  00205	48 8b cd	 mov	 rcx, rbp
  00208	0f 45 fb	 cmovne	 edi, ebx
  0020b	e8 00 00 00 00	 call	 strlen
  00210	44 8b c7	 mov	 r8d, edi
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11044
  0021a	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  0021e	e8 00 00 00 00	 call	 sprintf
  00223	45 03 ee	 add	 r13d, r14d
  00226	45 3b ee	 cmp	 r13d, r14d
  00229	75 c6		 jne	 SHORT $LL9@PrintAscii

; 155  :         unsigned k;
; 156  :         case sizeof(char) :
; 157  :             for (j = 0; j < cToPrint; j += elmsize) {

  0022b	41 ff c7	 inc	 r15d
  0022e	44 3b fe	 cmp	 r15d, esi
  00231	72 b3		 jb	 SHORT $LL6@PrintAscii
$LN5@PrintAscii:

; 181  :             }
; 182  :         break;
; 183  :     }
; 184  :     return 0;
; 185  : }

  00233	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00238	33 c0		 xor	 eax, eax
  0023a	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0023f	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00244	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00248	41 5f		 pop	 r15
  0024a	41 5e		 pop	 r14
  0024c	41 5d		 pop	 r13
  0024e	41 5c		 pop	 r12
  00250	5f		 pop	 rdi
  00251	c3		 ret	 0
PrintAscii ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT WriteString
_TEXT	SEGMENT
pszLineOfText$ = 80
WriteString PROC					; COMDAT

; 93   : {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 94   : 
; 95   :     CDEMOFINE((MFNBAR(1) "%s", pszLineOfText));

  00004	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG10979
  00010	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00015	45 33 c9	 xor	 r9d, r9d
  00018	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00029	33 d2		 xor	 edx, edx
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 _CdeMofine

; 96   : 
; 97   :     return 0;

  00032	33 c0		 xor	 eax, eax

; 98   : };

  00034	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00038	c3		 ret	 0
WriteString ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT GetMem8
_TEXT	SEGMENT
pAddr$ = 8
GetMem8	PROC						; COMDAT

; 75   :     unsigned char nRet, * p = (unsigned char*)pAddr;
; 76   :     nRet = 0xFF & *p;
; 77   :     return nRet;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 78   : 
; 79   : }

  00003	c3		 ret	 0
GetMem8	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File B:\edk2-staging.001\CdeValidationPkg\STDIO_H\stdiohfunctions\main.c
;	COMDAT UniDump
_TEXT	SEGMENT
nLineLengthHalf$1$ = 32
tv596 = 36
pBuffer$1$ = 40
pAddrXX$1$ = 48
rgszAddrXX$ = 56
elmsize$1$ = 176
ctrl$ = 176
elmcount$ = 184
startaddr$ = 192
pfnGetElm$ = 200
pfnWriteStr$ = 208
UniDump	PROC						; COMDAT

; 210  : {

$LN40:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	53		 push	 rbx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 211  : 
; 212  :     unsigned elmsize = 1 + ctrl.bit.elmsizemin1;

  0001e	8b e9		 mov	 ebp, ecx

; 213  :     unsigned u/*<unsigned index*/;
; 214  :     unsigned nLineLength = ctrl.bit.nBytesPerLine ? 1 + ctrl.bit.nBytesPerLine : 16;

  00020	8b c1		 mov	 eax, ecx
  00022	83 e5 07	 and	 ebp, 7
  00025	c1 e8 06	 shr	 eax, 6
  00028	ff c5		 inc	 ebp
  0002a	8b d9		 mov	 ebx, ecx
  0002c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0002f	89 ac 24 b0 00
	00 00		 mov	 DWORD PTR elmsize$1$[rsp], ebp
  00036	41 bf 10 00 00
	00		 mov	 r15d, 16

; 215  :     unsigned nLineLengthHalf = nLineLength / 2;
; 216  :     unsigned char* pBuffer = malloc(128);

  0003c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00041	49 8b f8	 mov	 rdi, r8
  00044	8d 40 01	 lea	 eax, DWORD PTR [rax+1]
  00047	44 0f 45 f8	 cmovne	 r15d, eax
  0004b	41 8b ef	 mov	 ebp, r15d
  0004e	d1 ed		 shr	 ebp, 1
  00050	89 6c 24 20	 mov	 DWORD PTR nLineLengthHalf$1$[rsp], ebp
  00054	e8 00 00 00 00	 call	 malloc

; 217  :     unsigned char* pTextLineBuf = malloc(18/*max. AddressSize*/ + 128/*max. characters*/ * 4 + 5/*Dash + szTwoSpaces*/);

  00059	b9 17 02 00 00	 mov	 ecx, 535		; 00000217H
  0005e	48 89 44 24 28	 mov	 QWORD PTR pBuffer$1$[rsp], rax
  00063	4c 8b e8	 mov	 r13, rax
  00066	e8 00 00 00 00	 call	 malloc
  0006b	48 8b f0	 mov	 rsi, rax

; 218  :     unsigned char* pb = (unsigned char*)&pBuffer[0];
; 219  :     unsigned short* pw = (unsigned short*)&pBuffer[0];
; 220  :     unsigned int* pdw = (unsigned int*)&pBuffer[0];
; 221  :     unsigned long long* pqw = (unsigned long long*) & pBuffer[0];
; 222  :     char* rgszAddrXX[] = { { "%016llX: " },{ "%08llX: " },{ "%04llX: " },{ "%02llX: " },{ "" } };/*<address field size strings*/
; 223  :     char* pAddrXX = rgszAddrXX[ctrl.bit.nAddrSize];
; 224  : 
; 225  :     pTextLineBuf[0] = '\0';

  0006e	45 33 c0	 xor	 r8d, r8d
  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11109

; 226  : 
; 227  :     for (u = 0; u < elmcount; u += elmsize) {

  00078	44 8b e3	 mov	 r12d, ebx
  0007b	48 89 44 24 38	 mov	 QWORD PTR rgszAddrXX$[rsp], rax
  00080	45 8b f0	 mov	 r14d, r8d
  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11111
  0008a	41 c1 ec 0d	 shr	 r12d, 13
  0008e	48 89 44 24 40	 mov	 QWORD PTR rgszAddrXX$[rsp+8], rax
  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11113
  0009a	48 89 44 24 48	 mov	 QWORD PTR rgszAddrXX$[rsp+16], rax
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11115
  000a6	48 89 44 24 50	 mov	 QWORD PTR rgszAddrXX$[rsp+24], rax
  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG11117
  000b2	48 89 44 24 58	 mov	 QWORD PTR rgszAddrXX$[rsp+32], rax
  000b7	8b c3		 mov	 eax, ebx
  000b9	48 c1 e8 03	 shr	 rax, 3
  000bd	83 e0 07	 and	 eax, 7
  000c0	44 88 06	 mov	 BYTE PTR [rsi], r8b
  000c3	48 8b 44 c4 38	 mov	 rax, QWORD PTR rgszAddrXX$[rsp+rax*8]
  000c8	48 89 44 24 30	 mov	 QWORD PTR pAddrXX$1$[rsp], rax
  000cd	44 39 84 24 b8
	00 00 00	 cmp	 DWORD PTR elmcount$[rsp], r8d
  000d5	0f 86 23 02 00
	00		 jbe	 $LN32@UniDump
  000db	8b c3		 mov	 eax, ebx
  000dd	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000e2	89 44 24 24	 mov	 DWORD PTR tv596[rsp], eax
$LL4@UniDump:

; 228  : 
; 229  :         if (0 == ctrl.bit.fNoDash)

  000e6	85 c0		 test	 eax, eax
  000e8	75 32		 jne	 SHORT $LN11@UniDump

; 230  :             if (0 == ((u) % nLineLengthHalf) && 0 != ((u) % nLineLength))

  000ea	33 d2		 xor	 edx, edx
  000ec	41 8b c6	 mov	 eax, r14d
  000ef	f7 f5		 div	 ebp
  000f1	85 d2		 test	 edx, edx
  000f3	75 27		 jne	 SHORT $LN11@UniDump
  000f5	33 d2		 xor	 edx, edx
  000f7	41 8b c6	 mov	 eax, r14d
  000fa	41 f7 f7	 div	 r15d
  000fd	85 d2		 test	 edx, edx
  000ff	74 1b		 je	 SHORT $LN11@UniDump

; 231  :                 sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "- ");

  00101	48 8b ce	 mov	 rcx, rsi
  00104	e8 00 00 00 00	 call	 strlen
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11120
  00110	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  00114	e8 00 00 00 00	 call	 sprintf
  00119	45 33 c0	 xor	 r8d, r8d
$LN11@UniDump:

; 232  : 
; 233  :         if (0 == (u % nLineLength))

  0011c	33 d2		 xor	 edx, edx
  0011e	45 8b ee	 mov	 r13d, r14d
  00121	41 8b c6	 mov	 eax, r14d
  00124	41 f7 f7	 div	 r15d
  00127	8b ea		 mov	 ebp, edx
  00129	85 d2		 test	 edx, edx
  0012b	75 3b		 jne	 SHORT $LN30@UniDump

; 234  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], pAddrXX, u + (1 == ctrl.bit.fBaseOfs ? startaddr : 0LL));

  0012d	8b c3		 mov	 eax, ebx
  0012f	48 8b ce	 mov	 rcx, rsi
  00132	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00137	f7 d8		 neg	 eax
  00139	48 1b ff	 sbb	 rdi, rdi
  0013c	48 23 bc 24 c0
	00 00 00	 and	 rdi, QWORD PTR startaddr$[rsp]
  00144	49 03 fd	 add	 rdi, r13
  00147	e8 00 00 00 00	 call	 strlen
  0014c	48 8b 54 24 30	 mov	 rdx, QWORD PTR pAddrXX$1$[rsp]
  00151	4c 8b c7	 mov	 r8, rdi
  00154	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  00158	e8 00 00 00 00	 call	 sprintf
  0015d	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR startaddr$[rsp]
  00165	45 33 c0	 xor	 r8d, r8d
$LN30@UniDump:

; 235  : 
; 236  :         switch (elmsize) {

  00168	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR elmsize$1$[rsp]
  0016f	83 e8 01	 sub	 eax, 1
  00172	0f 84 c1 00 00
	00		 je	 $LN13@UniDump
  00178	83 e8 01	 sub	 eax, 1
  0017b	74 7a		 je	 SHORT $LN14@UniDump
  0017d	83 e8 02	 sub	 eax, 2
  00180	74 45		 je	 SHORT $LN15@UniDump
  00182	83 f8 04	 cmp	 eax, 4
  00185	0f 85 d7 00 00
	00		 jne	 $LN35@UniDump

; 246  :         case 8: pqw[(u % nLineLength) / 8] = (unsigned long long)(*pfnGetElm)(startaddr + u);

  0018b	4a 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+r13]
  0018f	ff 94 24 c8 00
	00 00		 call	 QWORD PTR pfnGetElm$[rsp]
  00196	4c 8b 6c 24 28	 mov	 r13, QWORD PTR pBuffer$1$[rsp]

; 247  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "%016llX ", 0xFFFFFFFFFFFFFFFFLL & pqw[(u % nLineLength) / 8]);

  0019b	48 8b ce	 mov	 rcx, rsi
  0019e	48 8b f8	 mov	 rdi, rax
  001a1	48 8b c5	 mov	 rax, rbp
  001a4	48 c1 e8 03	 shr	 rax, 3
  001a8	49 89 7c c5 00	 mov	 QWORD PTR [r13+rax*8], rdi
  001ad	e8 00 00 00 00	 call	 strlen
  001b2	4c 8b c7	 mov	 r8, rdi
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11129
  001bc	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  001c0	e8 00 00 00 00	 call	 sprintf
  001c5	eb 6d		 jmp	 SHORT $LN37@UniDump
$LN15@UniDump:

; 242  :             break;
; 243  :         case 4: pdw[(u % nLineLength) / 4] = (unsigned int)(*pfnGetElm)(startaddr + u);

  001c7	4a 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+r13]
  001cb	ff 94 24 c8 00
	00 00		 call	 QWORD PTR pfnGetElm$[rsp]
  001d2	4c 8b 6c 24 28	 mov	 r13, QWORD PTR pBuffer$1$[rsp]

; 244  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "%08X ", 0xFFFFFFFF & pdw[(u % nLineLength) / 4]);

  001d7	48 8b ce	 mov	 rcx, rsi
  001da	48 8b f8	 mov	 rdi, rax
  001dd	48 8b c5	 mov	 rax, rbp
  001e0	48 c1 e8 02	 shr	 rax, 2
  001e4	41 89 7c 85 00	 mov	 DWORD PTR [r13+rax*4], edi
  001e9	e8 00 00 00 00	 call	 strlen
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11127

; 245  :             break;

  001f5	eb 31		 jmp	 SHORT $LN38@UniDump
$LN14@UniDump:

; 239  :             break;
; 240  :         case 2: pw[(u % nLineLength) / 2] = (unsigned short)(*pfnGetElm)(startaddr + u);

  001f7	4a 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+r13]
  001fb	ff 94 24 c8 00
	00 00		 call	 QWORD PTR pfnGetElm$[rsp]
  00202	4c 8b 6c 24 28	 mov	 r13, QWORD PTR pBuffer$1$[rsp]
  00207	48 8b c8	 mov	 rcx, rax

; 241  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "%04X ", 0xFFFF & pw[(u % nLineLength) / 2]);

  0020a	0f b7 f9	 movzx	 edi, cx
  0020d	48 8b c5	 mov	 rax, rbp
  00210	48 d1 e8	 shr	 rax, 1
  00213	66 41 89 4c 45
	00		 mov	 WORD PTR [r13+rax*2], cx
  00219	48 8b ce	 mov	 rcx, rsi
  0021c	e8 00 00 00 00	 call	 strlen
  00221	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11125
$LN38@UniDump:

; 248  :             break;
; 249  :         }
; 250  : 
; 251  :         if (0 == ((u + elmsize) % nLineLength)) {

  00228	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  0022c	44 8b c7	 mov	 r8d, edi
  0022f	e8 00 00 00 00	 call	 sprintf
$LN37@UniDump:
  00234	45 33 c0	 xor	 r8d, r8d
  00237	eb 2e		 jmp	 SHORT $LN5@UniDump
$LN13@UniDump:

; 237  :         case 1: pb[(u % nLineLength) / 1] = (unsigned char)(*pfnGetElm)(startaddr + u);

  00239	4a 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+r13]
  0023d	ff 94 24 c8 00
	00 00		 call	 QWORD PTR pfnGetElm$[rsp]
  00244	4c 8b 6c 24 28	 mov	 r13, QWORD PTR pBuffer$1$[rsp]

; 238  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "%02X ", 0xFF & pb[(u % nLineLength) / 1]);

  00249	48 8b ce	 mov	 rcx, rsi
  0024c	0f b6 f8	 movzx	 edi, al
  0024f	42 88 44 2d 00	 mov	 BYTE PTR [rbp+r13], al
  00254	e8 00 00 00 00	 call	 strlen
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11123
  00260	eb c6		 jmp	 SHORT $LN38@UniDump
$LN35@UniDump:

; 235  : 
; 236  :         switch (elmsize) {

  00262	4c 8b 6c 24 28	 mov	 r13, QWORD PTR pBuffer$1$[rsp]
$LN5@UniDump:

; 248  :             break;
; 249  :         }
; 250  : 
; 251  :         if (0 == ((u + elmsize) % nLineLength)) {

  00267	8b ac 24 b0 00
	00 00		 mov	 ebp, DWORD PTR elmsize$1$[rsp]
  0026e	33 d2		 xor	 edx, edx
  00270	44 03 f5	 add	 r14d, ebp
  00273	41 8b c6	 mov	 eax, r14d
  00276	41 f7 f7	 div	 r15d
  00279	85 d2		 test	 edx, edx
  0027b	75 63		 jne	 SHORT $LN2@UniDump

; 252  :             //
; 253  :             // print ascii values
; 254  :             //
; 255  :             if (0 == ctrl.bit.fNoAscii) {

  0027d	41 8b c4	 mov	 eax, r12d
  00280	83 e0 01	 and	 eax, 1
  00283	84 c0		 test	 al, al
  00285	75 31		 jne	 SHORT $LN18@UniDump

; 256  :                 sprintf(&pTextLineBuf[strlen(pTextLineBuf)], szTwoSpaces);

  00287	48 8b ce	 mov	 rcx, rsi
  0028a	e8 00 00 00 00	 call	 strlen
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:szTwoSpaces
  00296	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  0029a	e8 00 00 00 00	 call	 sprintf

; 257  :                 PrintAscii(&pBuffer[0], elmsize, nLineLength, &pTextLineBuf[strlen(pTextLineBuf)]);

  0029f	48 8b ce	 mov	 rcx, rsi
  002a2	e8 00 00 00 00	 call	 strlen
  002a7	45 8b c7	 mov	 r8d, r15d
  002aa	8b d5		 mov	 edx, ebp
  002ac	49 8b cd	 mov	 rcx, r13
  002af	4c 8d 0c 06	 lea	 r9, QWORD PTR [rsi+rax]
  002b3	e8 00 00 00 00	 call	 PrintAscii
$LN18@UniDump:

; 258  :             }
; 259  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "\n");

  002b8	48 8b ce	 mov	 rcx, rsi
  002bb	e8 00 00 00 00	 call	 strlen
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11132
  002c7	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  002cb	e8 00 00 00 00	 call	 sprintf

; 260  :             pfnWriteStr(pTextLineBuf);

  002d0	48 8b ce	 mov	 rcx, rsi
  002d3	ff 94 24 d0 00
	00 00		 call	 QWORD PTR pfnWriteStr$[rsp]

; 261  :             pTextLineBuf[0] = '\0';

  002da	45 33 c0	 xor	 r8d, r8d
  002dd	44 88 06	 mov	 BYTE PTR [rsi], r8b
$LN2@UniDump:

; 226  : 
; 227  :     for (u = 0; u < elmcount; u += elmsize) {

  002e0	8b 44 24 24	 mov	 eax, DWORD PTR tv596[rsp]
  002e4	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR startaddr$[rsp]
  002ec	8b 6c 24 20	 mov	 ebp, DWORD PTR nLineLengthHalf$1$[rsp]
  002f0	44 3b b4 24 b8
	00 00 00	 cmp	 r14d, DWORD PTR elmcount$[rsp]
  002f8	0f 82 e8 fd ff
	ff		 jb	 $LL4@UniDump
$LN32@UniDump:

; 262  :         }
; 263  :     }
; 264  :     //
; 265  :     // print remaining ASCII chars
; 266  :     //
; 267  :     if (1) {
; 268  :         unsigned rem = u % nLineLength/*remining hex numbers (filled w/ space)*/;

  002fe	33 d2		 xor	 edx, edx
  00300	41 8b c6	 mov	 eax, r14d
  00303	41 f7 f7	 div	 r15d

; 269  :         unsigned asc = nLineLength - rem/*ASCII characters not yet printed*/;

  00306	44 2b fa	 sub	 r15d, edx
  00309	8b ea		 mov	 ebp, edx

; 270  :         unsigned hex = asc / elmsize/*HEX numbers not yet printed == asc / elmsize*/;

  0030b	33 d2		 xor	 edx, edx
  0030d	41 8b c7	 mov	 eax, r15d
  00310	44 8b bc 24 b0
	00 00 00	 mov	 r15d, DWORD PTR elmsize$1$[rsp]
  00318	41 f7 f7	 div	 r15d

; 271  :         unsigned cSpaces = hex * elmsize * 2 + hex/*count spaces between the single numbers, depending on printsize*/;

  0031b	42 8d 0c 7d 01
	00 00 00	 lea	 ecx, DWORD PTR [r15*2+1]
  00323	44 8b f0	 mov	 r14d, eax
  00326	44 0f af f1	 imul	 r14d, ecx

; 272  :         unsigned cDashSpace = ctrl.bit.fNoDash ? 0 : (rem > nLineLengthHalf ? 0 : 2);/*count dash and space 0 / 2, depending on HEXDUMPPARMS.bit.fNoDash*/

  0032a	39 6c 24 20	 cmp	 DWORD PTR nLineLengthHalf$1$[rsp], ebp
  0032e	1b ff		 sbb	 edi, edi
  00330	f7 d7		 not	 edi
  00332	83 e7 02	 and	 edi, 2
  00335	81 e3 00 80 00
	00		 and	 ebx, 32768		; 00008000H
  0033b	41 0f 45 f8	 cmovne	 edi, r8d

; 273  : 
; 274  : 
; 275  :         if (0 != rem && 1 == ctrl.bit.fNoAscii)

  0033f	85 ed		 test	 ebp, ebp
  00341	74 22		 je	 SHORT $LN20@UniDump
  00343	41 8b c4	 mov	 eax, r12d
  00346	83 e0 01	 and	 eax, 1
  00349	84 c0		 test	 al, al
  0034b	74 18		 je	 SHORT $LN20@UniDump

; 276  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "\n");

  0034d	48 8b ce	 mov	 rcx, rsi
  00350	e8 00 00 00 00	 call	 strlen
  00355	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11135
  0035c	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  00360	e8 00 00 00 00	 call	 sprintf
$LN20@UniDump:

; 277  : 
; 278  :         if (0 == ctrl.bit.fNoAscii) {

  00365	41 83 e4 01	 and	 r12d, 1
  00369	45 84 e4	 test	 r12b, r12b
  0036c	0f 85 84 00 00
	00		 jne	 $LN21@UniDump

; 279  :             if (rem) {

  00372	85 ed		 test	 ebp, ebp
  00374	74 40		 je	 SHORT $LN22@UniDump

; 280  :                 unsigned x;
; 281  :                 for (x = 0; x < cSpaces + cDashSpace; x++) {

  00376	42 8d 04 37	 lea	 eax, DWORD PTR [rdi+r14]
  0037a	85 c0		 test	 eax, eax
  0037c	74 20		 je	 SHORT $LN8@UniDump
  0037e	8b d8		 mov	 ebx, eax
$LL9@UniDump:

; 282  :                     sprintf(&pTextLineBuf[strlen(pTextLineBuf)], szOneSpace);

  00380	48 8b ce	 mov	 rcx, rsi
  00383	e8 00 00 00 00	 call	 strlen
  00388	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:szOneSpace
  0038f	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  00393	e8 00 00 00 00	 call	 sprintf
  00398	48 83 eb 01	 sub	 rbx, 1
  0039c	75 e2		 jne	 SHORT $LL9@UniDump
$LN8@UniDump:

; 283  :                 }
; 284  :                 sprintf(&pTextLineBuf[strlen(pTextLineBuf)], szTwoSpaces);

  0039e	48 8b ce	 mov	 rcx, rsi
  003a1	e8 00 00 00 00	 call	 strlen
  003a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:szTwoSpaces
  003ad	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  003b1	e8 00 00 00 00	 call	 sprintf
$LN22@UniDump:

; 285  :             }
; 286  : 
; 287  :             PrintAscii(&pBuffer[0], elmsize, rem, &pTextLineBuf[strlen(pTextLineBuf)]);

  003b6	48 8b ce	 mov	 rcx, rsi
  003b9	e8 00 00 00 00	 call	 strlen
  003be	44 8b c5	 mov	 r8d, ebp
  003c1	41 8b d7	 mov	 edx, r15d
  003c4	49 8b cd	 mov	 rcx, r13
  003c7	4c 8d 0c 06	 lea	 r9, QWORD PTR [rsi+rax]
  003cb	e8 00 00 00 00	 call	 PrintAscii

; 288  : 
; 289  :             sprintf(&pTextLineBuf[strlen(pTextLineBuf)], "\n");

  003d0	48 8b ce	 mov	 rcx, rsi
  003d3	e8 00 00 00 00	 call	 strlen
  003d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG11138
  003df	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  003e3	e8 00 00 00 00	 call	 sprintf

; 290  :             pfnWriteStr(pTextLineBuf);

  003e8	48 8b ce	 mov	 rcx, rsi
  003eb	ff 94 24 d0 00
	00 00		 call	 QWORD PTR pfnWriteStr$[rsp]

; 291  :             pTextLineBuf[0] = '\0';

  003f2	33 d2		 xor	 edx, edx
  003f4	88 16		 mov	 BYTE PTR [rsi], dl
$LN21@UniDump:

; 292  :         }
; 293  :     }
; 294  : 
; 295  :     free(pTextLineBuf);

  003f6	48 8b ce	 mov	 rcx, rsi
  003f9	e8 00 00 00 00	 call	 free

; 296  :     free(pBuffer);

  003fe	49 8b cd	 mov	 rcx, r13
  00401	e8 00 00 00 00	 call	 free

; 297  : 
; 298  :     return 0;

  00406	33 c0		 xor	 eax, eax

; 299  : }

  00408	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0040c	41 5f		 pop	 r15
  0040e	41 5e		 pop	 r14
  00410	41 5d		 pop	 r13
  00412	41 5c		 pop	 r12
  00414	5f		 pop	 rdi
  00415	5e		 pop	 rsi
  00416	5d		 pop	 rbp
  00417	5b		 pop	 rbx
  00418	c3		 ret	 0
UniDump	ENDP
_TEXT	ENDS
END
